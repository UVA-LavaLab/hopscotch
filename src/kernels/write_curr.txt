
write_kernels.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <w_seq_memset() [clone ._omp_fn.0]>:
using namespace std;

double w_seq_memset(){
    volatile data_t* vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel
   0:	53                   	push   rbx
    {
        uint64_t tid = omp_get_thread_num();
   1:	e8 00 00 00 00       	call   6 <w_seq_memset() [clone ._omp_fn.0]+0x6>	2: R_X86_64_PC32	omp_get_thread_num-0x4
   6:	89 c3                	mov    ebx,eax
        uint64_t elem_per_thread = HS_ARRAY_ELEM / omp_get_num_threads();
   8:	e8 00 00 00 00       	call   d <w_seq_memset() [clone ._omp_fn.0]+0xd>	9: R_X86_64_PC32	omp_get_num_threads-0x4
   d:	31 d2                	xor    edx,edx
   f:	48 63 c8             	movsxd rcx,eax
  12:	b8 00 00 00 04       	mov    eax,0x4000000
  17:	48 f7 f1             	div    rcx
    {
      __warn_memset_zero_len ();
      return __dest;
    }
#endif
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
  1a:	48 63 fb             	movsxd rdi,ebx
  1d:	be 07 00 00 00       	mov    esi,0x7
  22:	48 c1 e7 03          	shl    rdi,0x3
using namespace std;

double w_seq_memset(){
    volatile data_t* vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel
  26:	5b                   	pop    rbx
  27:	48 8d 14 c5 00 00 00 00 	lea    rdx,[rax*8+0x0]
  2f:	48 0f af c7          	imul   rax,rdi
  33:	48 03 05 00 00 00 00 	add    rax,QWORD PTR [rip+0x0]        # 3a <w_seq_memset() [clone ._omp_fn.0]+0x3a>	36: R_X86_64_PC32	a-0x4
  3a:	48 89 c7             	mov    rdi,rax
  3d:	e9 00 00 00 00       	jmp    42 <w_seq_memset() [clone ._omp_fn.0]+0x42>	3e: R_X86_64_PC32	memset-0x4
  42:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  46:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

0000000000000050 <w_seq_fill() [clone ._omp_fn.1]>:
}

double w_seq_fill(){
    volatile data_t* vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
  50:	55                   	push   rbp
  51:	53                   	push   rbx
  52:	48 89 fb             	mov    rbx,rdi
  55:	48 83 ec 08          	sub    rsp,0x8
  59:	e8 00 00 00 00       	call   5e <w_seq_fill() [clone ._omp_fn.1]+0xe>	5a: R_X86_64_PC32	omp_get_num_threads-0x4
  5e:	48 63 e8             	movsxd rbp,eax
  61:	e8 00 00 00 00       	call   66 <w_seq_fill() [clone ._omp_fn.1]+0x16>	62: R_X86_64_PC32	omp_get_thread_num-0x4
  66:	31 d2                	xor    edx,edx
  68:	48 63 c8             	movsxd rcx,eax
  6b:	b8 00 00 00 04       	mov    eax,0x4000000
  70:	48 f7 f5             	div    rbp
  73:	48 39 d1             	cmp    rcx,rdx
  76:	73 06                	jae    7e <w_seq_fill() [clone ._omp_fn.1]+0x2e>
  78:	48 83 c0 01          	add    rax,0x1
  7c:	31 d2                	xor    edx,edx
  7e:	48 0f af c8          	imul   rcx,rax
  82:	48 01 ca             	add    rdx,rcx
  85:	48 01 d0             	add    rax,rdx
  88:	48 39 c2             	cmp    rdx,rax
  8b:	73 23                	jae    b0 <w_seq_fill() [clone ._omp_fn.1]+0x60>
  8d:	48 8b 0b             	mov    rcx,QWORD PTR [rbx]
  90:	48 8d 14 d1          	lea    rdx,[rcx+rdx*8]
  94:	48 8d 04 c1          	lea    rax,[rcx+rax*8]
  98:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        vol_a[i] = 7;
  a0:	48 c7 02 07 00 00 00 	mov    QWORD PTR [rdx],0x7
  a7:	48 83 c2 08          	add    rdx,0x8
  ab:	48 39 d0             	cmp    rax,rdx
  ae:	75 f0                	jne    a0 <w_seq_fill() [clone ._omp_fn.1]+0x50>
}

double w_seq_fill(){
    volatile data_t* vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
  b0:	48 83 c4 08          	add    rsp,0x8
  b4:	5b                   	pop    rbx
  b5:	5d                   	pop    rbp
  b6:	c3                   	ret    
  b7:	66 0f 1f 84 00 00 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]

00000000000000c0 <w_rand_ind() [clone ._omp_fn.2]>:
}

double w_rand_ind(){
    volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
  c0:	55                   	push   rbp
  c1:	53                   	push   rbx
  c2:	48 89 fb             	mov    rbx,rdi
  c5:	48 83 ec 08          	sub    rsp,0x8
  c9:	e8 00 00 00 00       	call   ce <w_rand_ind() [clone ._omp_fn.2]+0xe>	ca: R_X86_64_PC32	omp_get_num_threads-0x4
  ce:	48 63 e8             	movsxd rbp,eax
  d1:	e8 00 00 00 00       	call   d6 <w_rand_ind() [clone ._omp_fn.2]+0x16>	d2: R_X86_64_PC32	omp_get_thread_num-0x4
  d6:	31 d2                	xor    edx,edx
  d8:	48 63 c8             	movsxd rcx,eax
  db:	b8 00 00 00 04       	mov    eax,0x4000000
  e0:	48 f7 f5             	div    rbp
  e3:	48 39 d1             	cmp    rcx,rdx
  e6:	73 06                	jae    ee <w_rand_ind() [clone ._omp_fn.2]+0x2e>
  e8:	48 83 c0 01          	add    rax,0x1
  ec:	31 d2                	xor    edx,edx
  ee:	48 0f af c8          	imul   rcx,rax
  f2:	48 01 ca             	add    rdx,rcx
  f5:	48 01 d0             	add    rax,rdx
  f8:	48 39 c2             	cmp    rdx,rax
  fb:	73 3a                	jae    137 <w_rand_ind() [clone ._omp_fn.2]+0x77>
  fd:	be ef be ad de       	mov    esi,0xdeadbeef
 102:	4c 8b 03             	mov    r8,QWORD PTR [rbx]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        uint64_t idx = ((i * 0xDEADBEEF) ^ 0xC0FFEE0B) % HS_ARRAY_ELEM;
        vol_a[idx] = 7;
 105:	bf 0b ee ff c0       	mov    edi,0xc0ffee0b
 10a:	48 0f af d6          	imul   rdx,rsi
 10e:	48 0f af c6          	imul   rax,rsi
 112:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
 118:	48 89 d1             	mov    rcx,rdx
 11b:	48 01 f2             	add    rdx,rsi
 11e:	48 31 f9             	xor    rcx,rdi
 121:	81 e1 ff ff ff 03    	and    ecx,0x3ffffff
 127:	48 39 d0             	cmp    rax,rdx
 12a:	49 8d 0c c8          	lea    rcx,[r8+rcx*8]
 12e:	48 c7 01 07 00 00 00 	mov    QWORD PTR [rcx],0x7
 135:	75 e1                	jne    118 <w_rand_ind() [clone ._omp_fn.2]+0x58>
}

double w_rand_ind(){
    volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 137:	48 83 c4 08          	add    rsp,0x8
 13b:	5b                   	pop    rbx
 13c:	5d                   	pop    rbp
 13d:	c3                   	ret    
 13e:	66 90                	xchg   ax,ax

0000000000000140 <w_stride_2() [clone ._omp_fn.3]>:
    return get_time() - elapsed;
}

double w_stride_2(){
    double elapsed = get_time();
    #pragma omp parallel for
 140:	53                   	push   rbx
 141:	e8 00 00 00 00       	call   146 <w_stride_2() [clone ._omp_fn.3]+0x6>	142: R_X86_64_PC32	omp_get_num_threads-0x4
 146:	48 63 d8             	movsxd rbx,eax
 149:	e8 00 00 00 00       	call   14e <w_stride_2() [clone ._omp_fn.3]+0xe>	14a: R_X86_64_PC32	omp_get_thread_num-0x4
 14e:	31 d2                	xor    edx,edx
 150:	48 63 c8             	movsxd rcx,eax
 153:	b8 00 00 00 02       	mov    eax,0x2000000
 158:	48 f7 f3             	div    rbx
 15b:	48 39 d1             	cmp    rcx,rdx
 15e:	73 06                	jae    166 <w_stride_2() [clone ._omp_fn.3]+0x26>
 160:	48 83 c0 01          	add    rax,0x1
 164:	31 d2                	xor    edx,edx
 166:	48 0f af c8          	imul   rcx,rax
 16a:	48 01 ca             	add    rdx,rcx
 16d:	48 01 d0             	add    rax,rdx
 170:	48 39 c2             	cmp    rdx,rax
 173:	73 24                	jae    199 <w_stride_2() [clone ._omp_fn.3]+0x59>
 175:	48 8b 0d 00 00 00 00 	mov    rcx,QWORD PTR [rip+0x0]        # 17c <w_stride_2() [clone ._omp_fn.3]+0x3c>	178: R_X86_64_PC32	a-0x4
 17c:	48 01 d2             	add    rdx,rdx
 17f:	48 01 c0             	add    rax,rax
 182:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 2) {
        a[i] = 7;
 188:	48 c7 04 d1 07 00 00 00 	mov    QWORD PTR [rcx+rdx*8],0x7
 190:	48 83 c2 02          	add    rdx,0x2
 194:	48 39 d0             	cmp    rax,rdx
 197:	77 ef                	ja     188 <w_stride_2() [clone ._omp_fn.3]+0x48>
    return get_time() - elapsed;
}

double w_stride_2(){
    double elapsed = get_time();
    #pragma omp parallel for
 199:	5b                   	pop    rbx
 19a:	c3                   	ret    
 19b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000000001a0 <w_stride_4() [clone ._omp_fn.4]>:
    return get_time() - elapsed;
}

double w_stride_4(){
    double elapsed = get_time();
    #pragma omp parallel for
 1a0:	53                   	push   rbx
 1a1:	e8 00 00 00 00       	call   1a6 <w_stride_4() [clone ._omp_fn.4]+0x6>	1a2: R_X86_64_PC32	omp_get_num_threads-0x4
 1a6:	48 63 d8             	movsxd rbx,eax
 1a9:	e8 00 00 00 00       	call   1ae <w_stride_4() [clone ._omp_fn.4]+0xe>	1aa: R_X86_64_PC32	omp_get_thread_num-0x4
 1ae:	31 d2                	xor    edx,edx
 1b0:	48 63 c8             	movsxd rcx,eax
 1b3:	b8 00 00 00 01       	mov    eax,0x1000000
 1b8:	48 f7 f3             	div    rbx
 1bb:	48 39 d1             	cmp    rcx,rdx
 1be:	73 06                	jae    1c6 <w_stride_4() [clone ._omp_fn.4]+0x26>
 1c0:	48 83 c0 01          	add    rax,0x1
 1c4:	31 d2                	xor    edx,edx
 1c6:	48 0f af c8          	imul   rcx,rax
 1ca:	48 01 ca             	add    rdx,rcx
 1cd:	48 01 d0             	add    rax,rdx
 1d0:	48 39 c2             	cmp    rdx,rax
 1d3:	73 24                	jae    1f9 <w_stride_4() [clone ._omp_fn.4]+0x59>
 1d5:	48 8b 0d 00 00 00 00 	mov    rcx,QWORD PTR [rip+0x0]        # 1dc <w_stride_4() [clone ._omp_fn.4]+0x3c>	1d8: R_X86_64_PC32	a-0x4
 1dc:	48 c1 e2 02          	shl    rdx,0x2
 1e0:	48 c1 e0 02          	shl    rax,0x2
 1e4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 4) {
        a[i] = 7;
 1e8:	48 c7 04 d1 07 00 00 00 	mov    QWORD PTR [rcx+rdx*8],0x7
 1f0:	48 83 c2 04          	add    rdx,0x4
 1f4:	48 39 d0             	cmp    rax,rdx
 1f7:	77 ef                	ja     1e8 <w_stride_4() [clone ._omp_fn.4]+0x48>
    return get_time() - elapsed;
}

double w_stride_4(){
    double elapsed = get_time();
    #pragma omp parallel for
 1f9:	5b                   	pop    rbx
 1fa:	c3                   	ret    
 1fb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000000200 <w_stride_8() [clone ._omp_fn.5]>:
    return get_time() - elapsed;
}

double w_stride_8(){
    double elapsed = get_time();
    #pragma omp parallel for
 200:	53                   	push   rbx
 201:	e8 00 00 00 00       	call   206 <w_stride_8() [clone ._omp_fn.5]+0x6>	202: R_X86_64_PC32	omp_get_num_threads-0x4
 206:	48 63 d8             	movsxd rbx,eax
 209:	e8 00 00 00 00       	call   20e <w_stride_8() [clone ._omp_fn.5]+0xe>	20a: R_X86_64_PC32	omp_get_thread_num-0x4
 20e:	31 d2                	xor    edx,edx
 210:	48 63 c8             	movsxd rcx,eax
 213:	b8 00 00 80 00       	mov    eax,0x800000
 218:	48 f7 f3             	div    rbx
 21b:	48 39 d1             	cmp    rcx,rdx
 21e:	73 06                	jae    226 <w_stride_8() [clone ._omp_fn.5]+0x26>
 220:	48 83 c0 01          	add    rax,0x1
 224:	31 d2                	xor    edx,edx
 226:	48 0f af c8          	imul   rcx,rax
 22a:	48 01 ca             	add    rdx,rcx
 22d:	48 01 d0             	add    rax,rdx
 230:	48 39 c2             	cmp    rdx,rax
 233:	73 24                	jae    259 <w_stride_8() [clone ._omp_fn.5]+0x59>
 235:	48 8b 0d 00 00 00 00 	mov    rcx,QWORD PTR [rip+0x0]        # 23c <w_stride_8() [clone ._omp_fn.5]+0x3c>	238: R_X86_64_PC32	a-0x4
 23c:	48 c1 e2 03          	shl    rdx,0x3
 240:	48 c1 e0 03          	shl    rax,0x3
 244:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 8) {
        a[i] = 7;
 248:	48 c7 04 d1 07 00 00 00 	mov    QWORD PTR [rcx+rdx*8],0x7
 250:	48 83 c2 08          	add    rdx,0x8
 254:	48 39 d0             	cmp    rax,rdx
 257:	77 ef                	ja     248 <w_stride_8() [clone ._omp_fn.5]+0x48>
    return get_time() - elapsed;
}

double w_stride_8(){
    double elapsed = get_time();
    #pragma omp parallel for
 259:	5b                   	pop    rbx
 25a:	c3                   	ret    
 25b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000000260 <w_stride_16() [clone ._omp_fn.6]>:
    return get_time() - elapsed;
}

double w_stride_16(){
    double elapsed = get_time();
    #pragma omp parallel for
 260:	53                   	push   rbx
 261:	e8 00 00 00 00       	call   266 <w_stride_16() [clone ._omp_fn.6]+0x6>	262: R_X86_64_PC32	omp_get_num_threads-0x4
 266:	48 63 d8             	movsxd rbx,eax
 269:	e8 00 00 00 00       	call   26e <w_stride_16() [clone ._omp_fn.6]+0xe>	26a: R_X86_64_PC32	omp_get_thread_num-0x4
 26e:	31 d2                	xor    edx,edx
 270:	48 63 c8             	movsxd rcx,eax
 273:	b8 00 00 40 00       	mov    eax,0x400000
 278:	48 f7 f3             	div    rbx
 27b:	48 39 d1             	cmp    rcx,rdx
 27e:	73 06                	jae    286 <w_stride_16() [clone ._omp_fn.6]+0x26>
 280:	48 83 c0 01          	add    rax,0x1
 284:	31 d2                	xor    edx,edx
 286:	48 0f af c8          	imul   rcx,rax
 28a:	48 01 ca             	add    rdx,rcx
 28d:	48 01 d0             	add    rax,rdx
 290:	48 39 c2             	cmp    rdx,rax
 293:	73 24                	jae    2b9 <w_stride_16() [clone ._omp_fn.6]+0x59>
 295:	48 8b 0d 00 00 00 00 	mov    rcx,QWORD PTR [rip+0x0]        # 29c <w_stride_16() [clone ._omp_fn.6]+0x3c>	298: R_X86_64_PC32	a-0x4
 29c:	48 c1 e2 04          	shl    rdx,0x4
 2a0:	48 c1 e0 04          	shl    rax,0x4
 2a4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 16) {
        a[i] = 7;
 2a8:	48 c7 04 d1 07 00 00 00 	mov    QWORD PTR [rcx+rdx*8],0x7
 2b0:	48 83 c2 10          	add    rdx,0x10
 2b4:	48 39 d0             	cmp    rax,rdx
 2b7:	77 ef                	ja     2a8 <w_stride_16() [clone ._omp_fn.6]+0x48>
    return get_time() - elapsed;
}

double w_stride_16(){
    double elapsed = get_time();
    #pragma omp parallel for
 2b9:	5b                   	pop    rbx
 2ba:	c3                   	ret    
 2bb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000000002c0 <w_stride_32() [clone ._omp_fn.7]>:
    return get_time() - elapsed;
}

double w_stride_32(){
    double elapsed = get_time();
    #pragma omp parallel for
 2c0:	53                   	push   rbx
 2c1:	e8 00 00 00 00       	call   2c6 <w_stride_32() [clone ._omp_fn.7]+0x6>	2c2: R_X86_64_PC32	omp_get_num_threads-0x4
 2c6:	48 63 d8             	movsxd rbx,eax
 2c9:	e8 00 00 00 00       	call   2ce <w_stride_32() [clone ._omp_fn.7]+0xe>	2ca: R_X86_64_PC32	omp_get_thread_num-0x4
 2ce:	31 d2                	xor    edx,edx
 2d0:	48 63 c8             	movsxd rcx,eax
 2d3:	b8 00 00 20 00       	mov    eax,0x200000
 2d8:	48 f7 f3             	div    rbx
 2db:	48 39 d1             	cmp    rcx,rdx
 2de:	73 06                	jae    2e6 <w_stride_32() [clone ._omp_fn.7]+0x26>
 2e0:	48 83 c0 01          	add    rax,0x1
 2e4:	31 d2                	xor    edx,edx
 2e6:	48 0f af c8          	imul   rcx,rax
 2ea:	48 01 ca             	add    rdx,rcx
 2ed:	48 01 d0             	add    rax,rdx
 2f0:	48 39 c2             	cmp    rdx,rax
 2f3:	73 24                	jae    319 <w_stride_32() [clone ._omp_fn.7]+0x59>
 2f5:	48 8b 0d 00 00 00 00 	mov    rcx,QWORD PTR [rip+0x0]        # 2fc <w_stride_32() [clone ._omp_fn.7]+0x3c>	2f8: R_X86_64_PC32	a-0x4
 2fc:	48 c1 e2 05          	shl    rdx,0x5
 300:	48 c1 e0 05          	shl    rax,0x5
 304:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 32) {
        a[i] = 7;
 308:	48 c7 04 d1 07 00 00 00 	mov    QWORD PTR [rcx+rdx*8],0x7
 310:	48 83 c2 20          	add    rdx,0x20
 314:	48 39 d0             	cmp    rax,rdx
 317:	77 ef                	ja     308 <w_stride_32() [clone ._omp_fn.7]+0x48>
    return get_time() - elapsed;
}

double w_stride_32(){
    double elapsed = get_time();
    #pragma omp parallel for
 319:	5b                   	pop    rbx
 31a:	c3                   	ret    
 31b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000000320 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]>:
}

double w_tile(uint64_t L, uint64_t K){
//double w_tile(){
    double elapsed = get_time();
    #pragma omp parallel for
 320:	41 54                	push   r12
 322:	55                   	push   rbp
 323:	53                   	push   rbx
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
 324:	48 8b 6f 08          	mov    rbp,QWORD PTR [rdi+0x8]
}

double w_tile(uint64_t L, uint64_t K){
//double w_tile(){
    double elapsed = get_time();
    #pragma omp parallel for
 328:	48 89 fb             	mov    rbx,rdi
 32b:	e8 00 00 00 00       	call   330 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x10>	32c: R_X86_64_PC32	omp_get_num_threads-0x4
 330:	4c 63 e0             	movsxd r12,eax
 333:	e8 00 00 00 00       	call   338 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x18>	334: R_X86_64_PC32	omp_get_thread_num-0x4
 338:	48 63 f0             	movsxd rsi,eax
 33b:	48 8d 85 ff ff ff 03 	lea    rax,[rbp+0x3ffffff]
 342:	31 d2                	xor    edx,edx
 344:	48 f7 f5             	div    rbp
 347:	31 d2                	xor    edx,edx
 349:	49 f7 f4             	div    r12
 34c:	48 39 d6             	cmp    rsi,rdx
 34f:	73 06                	jae    357 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x37>
 351:	48 83 c0 01          	add    rax,0x1
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
 355:	31 d2                	xor    edx,edx
 357:	48 0f af f0          	imul   rsi,rax
 35b:	48 01 d6             	add    rsi,rdx
 35e:	48 8d 3c 30          	lea    rdi,[rax+rsi*1]
 362:	48 39 fe             	cmp    rsi,rdi
 365:	73 48                	jae    3af <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x8f>
 367:	48 0f af f5          	imul   rsi,rbp
 36b:	48 8b 05 00 00 00 00 	mov    rax,QWORD PTR [rip+0x0]        # 372 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x52>	36e: R_X86_64_PC32	a-0x4
 372:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
 375:	48 0f af fd          	imul   rdi,rbp
 379:	4c 8d 04 ed 00 00 00 00 	lea    r8,[rbp*8+0x0]
 381:	48 8d 0c f0          	lea    rcx,[rax+rsi*8]
 385:	0f 1f 00             	nop    DWORD PTR [rax]
        for(uint64_t j = 0; j < L; j++) {
 388:	31 c0                	xor    eax,eax
 38a:	48 85 d2             	test   rdx,rdx
 38d:	74 15                	je     3a4 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x84>
 38f:	90                   	nop
            a[i+j] = 7;
 390:	48 c7 04 c1 07 00 00 00 	mov    QWORD PTR [rcx+rax*8],0x7
double w_tile(uint64_t L, uint64_t K){
//double w_tile(){
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
 398:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
 39b:	48 83 c0 01          	add    rax,0x1
 39f:	48 39 c2             	cmp    rdx,rax
 3a2:	77 ec                	ja     390 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x70>
 3a4:	48 01 ee             	add    rsi,rbp
 3a7:	4c 01 c1             	add    rcx,r8
 3aa:	48 39 f7             	cmp    rdi,rsi
 3ad:	77 d9                	ja     388 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x68>
}

double w_tile(uint64_t L, uint64_t K){
//double w_tile(){
    double elapsed = get_time();
    #pragma omp parallel for
 3af:	5b                   	pop    rbx
 3b0:	5d                   	pop    rbp
 3b1:	41 5c                	pop    r12
 3b3:	c3                   	ret    
 3b4:	66 90                	xchg   ax,ax
 3b6:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

00000000000003c0 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]>:
    return get_time() - elapsed;
}

double w_dma(data_t** addr, uint64_t* len, uint64_t count) {
    double elapsed = get_time();
    #pragma omp parallel for
 3c0:	41 54                	push   r12
 3c2:	55                   	push   rbp
 3c3:	53                   	push   rbx
    for(uint64_t i = 0; i < count; i++) {
 3c4:	48 8b 5f 10          	mov    rbx,QWORD PTR [rdi+0x10]
 3c8:	48 85 db             	test   rbx,rbx
 3cb:	0f 84 61 01 00 00    	je     532 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x172>
 3d1:	48 89 fd             	mov    rbp,rdi
 3d4:	e8 00 00 00 00       	call   3d9 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x19>	3d5: R_X86_64_PC32	omp_get_num_threads-0x4
 3d9:	4c 63 e0             	movsxd r12,eax
 3dc:	e8 00 00 00 00       	call   3e1 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x21>	3dd: R_X86_64_PC32	omp_get_thread_num-0x4
 3e1:	31 d2                	xor    edx,edx
 3e3:	4c 63 c0             	movsxd r8,eax
 3e6:	48 89 d8             	mov    rax,rbx
 3e9:	49 f7 f4             	div    r12
 3ec:	49 39 d0             	cmp    r8,rdx
 3ef:	73 06                	jae    3f7 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x37>
 3f1:	48 83 c0 01          	add    rax,0x1
 3f5:	31 d2                	xor    edx,edx
 3f7:	4c 0f af c0          	imul   r8,rax
 3fb:	49 01 d0             	add    r8,rdx
 3fe:	4e 8d 0c 00          	lea    r9,[rax+r8*1]
 402:	4d 39 c8             	cmp    r8,r9
 405:	0f 83 27 01 00 00    	jae    532 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x172>
 40b:	4c 8b 55 08          	mov    r10,QWORD PTR [rbp+0x8]
 40f:	48 8b 7d 00          	mov    rdi,QWORD PTR [rbp+0x0]
 413:	66 0f 6f 05 00 00 00 00 	movdqa xmm0,XMMWORD PTR [rip+0x0]        # 41b <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x5b>	417: R_X86_64_PC32	.LC9-0x4
 41b:	e9 a9 00 00 00       	jmp    4c9 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x109>
 420:	48 83 f8 01          	cmp    rax,0x1
        const uint64_t c_len = len[i];
        data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
            *c_addr++ = 7;
 424:	4c 8d 5a 08          	lea    r11,[rdx+0x8]
 428:	48 c7 02 07 00 00 00 	mov    QWORD PTR [rdx],0x7
 42f:	0f 84 13 01 00 00    	je     548 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x188>
 435:	48 83 f8 02          	cmp    rax,0x2
 439:	4c 8d 5a 10          	lea    r11,[rdx+0x10]
 43d:	48 c7 42 08 07 00 00 00 	mov    QWORD PTR [rdx+0x8],0x7
 445:	0f 84 1d 01 00 00    	je     568 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x1a8>
 44b:	48 83 f8 03          	cmp    rax,0x3
 44f:	4c 8d 5a 18          	lea    r11,[rdx+0x18]
 453:	48 c7 42 10 07 00 00 00 	mov    QWORD PTR [rdx+0x10],0x7
 45b:	0f 84 f7 00 00 00    	je     558 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x198>
 461:	48 83 f8 04          	cmp    rax,0x4
 465:	4c 8d 5a 20          	lea    r11,[rdx+0x20]
 469:	48 c7 42 18 07 00 00 00 	mov    QWORD PTR [rdx+0x18],0x7
 471:	0f 84 11 01 00 00    	je     588 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x1c8>
 477:	48 83 f8 05          	cmp    rax,0x5
 47b:	4c 8d 5a 28          	lea    r11,[rdx+0x28]
 47f:	48 c7 42 20 07 00 00 00 	mov    QWORD PTR [rdx+0x20],0x7
 487:	0f 84 eb 00 00 00    	je     578 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x1b8>
 48d:	4c 8d 5a 30          	lea    r11,[rdx+0x30]
 491:	48 c7 42 28 07 00 00 00 	mov    QWORD PTR [rdx+0x28],0x7
 499:	48 89 c1             	mov    rcx,rax
 49c:	48 39 c8             	cmp    rax,rcx
 49f:	74 1f                	je     4c0 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x100>
 4a1:	48 29 c8             	sub    rax,rcx
 4a4:	48 8d 70 fe          	lea    rsi,[rax-0x2]
 4a8:	48 d1 ee             	shr    rsi,1
 4ab:	48 83 c6 01          	add    rsi,0x1
 4af:	48 83 f8 01          	cmp    rax,0x1
 4b3:	48 8d 1c 36          	lea    rbx,[rsi+rsi*1]
 4b7:	75 50                	jne    509 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x149>
 4b9:	49 c7 03 07 00 00 00 	mov    QWORD PTR [r11],0x7
 4c0:	49 83 c0 01          	add    r8,0x1
 4c4:	4d 39 c1             	cmp    r9,r8
 4c7:	74 69                	je     532 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x172>

double w_dma(data_t** addr, uint64_t* len, uint64_t count) {
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < count; i++) {
        const uint64_t c_len = len[i];
 4c9:	4b 8b 04 c2          	mov    rax,QWORD PTR [r10+r8*8]
        data_t* c_addr = addr[i];
 4cd:	4a 8b 14 c7          	mov    rdx,QWORD PTR [rdi+r8*8]
        for(uint64_t j = 0; j < c_len; j++) {
 4d1:	48 85 c0             	test   rax,rax
 4d4:	74 ea                	je     4c0 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x100>
 4d6:	48 89 d1             	mov    rcx,rdx
 4d9:	48 c1 e1 3c          	shl    rcx,0x3c
 4dd:	48 c1 e9 3f          	shr    rcx,0x3f
 4e1:	48 39 c1             	cmp    rcx,rax
 4e4:	48 0f 47 c8          	cmova  rcx,rax
 4e8:	48 83 f8 06          	cmp    rax,0x6
 4ec:	0f 86 2e ff ff ff    	jbe    420 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x60>
 4f2:	48 85 c9             	test   rcx,rcx
 4f5:	75 40                	jne    537 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x177>
 4f7:	48 8d 70 fe          	lea    rsi,[rax-0x2]
double w_dma(data_t** addr, uint64_t* len, uint64_t count) {
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < count; i++) {
        const uint64_t c_len = len[i];
        data_t* c_addr = addr[i];
 4fb:	49 89 d3             	mov    r11,rdx
 4fe:	48 d1 ee             	shr    rsi,1
 501:	48 83 c6 01          	add    rsi,0x1
 505:	48 8d 1c 36          	lea    rbx,[rsi+rsi*1]
 509:	48 8d 0c ca          	lea    rcx,[rdx+rcx*8]
 50d:	31 d2                	xor    edx,edx
 50f:	48 83 c2 01          	add    rdx,0x1
 513:	48 83 c1 10          	add    rcx,0x10
        for(uint64_t j = 0; j < c_len; j++) {
            *c_addr++ = 7;
 517:	0f 29 41 f0          	movaps XMMWORD PTR [rcx-0x10],xmm0
 51b:	48 39 d6             	cmp    rsi,rdx
 51e:	77 ef                	ja     50f <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x14f>
 520:	48 39 d8             	cmp    rax,rbx
 523:	4d 8d 1c db          	lea    r11,[r11+rbx*8]
 527:	75 90                	jne    4b9 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0xf9>
 529:	49 83 c0 01          	add    r8,0x1
 52d:	4d 39 c1             	cmp    r9,r8
 530:	75 97                	jne    4c9 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x109>
    return get_time() - elapsed;
}

double w_dma(data_t** addr, uint64_t* len, uint64_t count) {
    double elapsed = get_time();
    #pragma omp parallel for
 532:	5b                   	pop    rbx
 533:	5d                   	pop    rbp
 534:	41 5c                	pop    r12
 536:	c3                   	ret    
    for(uint64_t i = 0; i < count; i++) {
        const uint64_t c_len = len[i];
        data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
            *c_addr++ = 7;
 537:	4c 8d 5a 08          	lea    r11,[rdx+0x8]
 53b:	48 c7 02 07 00 00 00 	mov    QWORD PTR [rdx],0x7
 542:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
 548:	b9 01 00 00 00       	mov    ecx,0x1
 54d:	e9 4a ff ff ff       	jmp    49c <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0xdc>
 552:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
 558:	b9 03 00 00 00       	mov    ecx,0x3
 55d:	e9 3a ff ff ff       	jmp    49c <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0xdc>
 562:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
 568:	b9 02 00 00 00       	mov    ecx,0x2
 56d:	e9 2a ff ff ff       	jmp    49c <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0xdc>
 572:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
 578:	b9 05 00 00 00       	mov    ecx,0x5
 57d:	e9 1a ff ff ff       	jmp    49c <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0xdc>
 582:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
 588:	b9 04 00 00 00       	mov    ecx,0x4
 58d:	e9 0a ff ff ff       	jmp    49c <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0xdc>
 592:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
 596:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

00000000000005a0 <w_seq_memset()>:
#include "common.h"

using namespace std;

double w_seq_memset(){
 5a0:	48 83 ec 18          	sub    rsp,0x18
    volatile data_t* vol_a = a;
    double elapsed = get_time();
 5a4:	e8 00 00 00 00       	call   5a9 <w_seq_memset()+0x9>	5a5: R_X86_64_PC32	get_time()-0x4
 5a9:	31 c9                	xor    ecx,ecx
 5ab:	31 d2                	xor    edx,edx
 5ad:	31 f6                	xor    esi,esi
 5af:	bf 00 00 00 00       	mov    edi,0x0	5b0: R_X86_64_32	.text
 5b4:	f2 0f 11 44 24 08    	movsd  QWORD PTR [rsp+0x8],xmm0
 5ba:	e8 00 00 00 00       	call   5bf <w_seq_memset()+0x1f>	5bb: R_X86_64_PC32	GOMP_parallel-0x4
        uint64_t tid = omp_get_thread_num();
        uint64_t elem_per_thread = HS_ARRAY_ELEM / omp_get_num_threads();
        uint64_t offset = tid * elem_per_thread;        
        memset(a + offset, 7, elem_per_thread * sizeof(data_t));
    }
    return get_time() - elapsed;
 5bf:	e8 00 00 00 00       	call   5c4 <w_seq_memset()+0x24>	5c0: R_X86_64_PC32	get_time()-0x4
 5c4:	f2 0f 5c 44 24 08    	subsd  xmm0,QWORD PTR [rsp+0x8]
}
 5ca:	48 83 c4 18          	add    rsp,0x18
 5ce:	c3                   	ret    
 5cf:	90                   	nop

00000000000005d0 <w_seq_fill()>:

double w_seq_fill(){
 5d0:	53                   	push   rbx
 5d1:	48 83 ec 20          	sub    rsp,0x20
    volatile data_t* vol_a = a;
 5d5:	48 8b 1d 00 00 00 00 	mov    rbx,QWORD PTR [rip+0x0]        # 5dc <w_seq_fill()+0xc>	5d8: R_X86_64_PC32	a-0x4
        memset(a + offset, 7, elem_per_thread * sizeof(data_t));
    }
    return get_time() - elapsed;
}

double w_seq_fill(){
 5dc:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 5e5:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
 5ea:	31 c0                	xor    eax,eax
    volatile data_t* vol_a = a;
    double elapsed = get_time();
 5ec:	e8 00 00 00 00       	call   5f1 <w_seq_fill()+0x21>	5ed: R_X86_64_PC32	get_time()-0x4
 5f1:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
 5f6:	31 c9                	xor    ecx,ecx
 5f8:	31 d2                	xor    edx,edx
 5fa:	bf 00 00 00 00       	mov    edi,0x0	5fb: R_X86_64_32	.text+0x50
 5ff:	f2 0f 11 44 24 08    	movsd  QWORD PTR [rsp+0x8],xmm0
    #pragma omp parallel for
 605:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
 60a:	e8 00 00 00 00       	call   60f <w_seq_fill()+0x3f>	60b: R_X86_64_PC32	GOMP_parallel-0x4
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        vol_a[i] = 7;
    }
    return get_time() - elapsed;
 60f:	e8 00 00 00 00       	call   614 <w_seq_fill()+0x44>	610: R_X86_64_PC32	get_time()-0x4
}
 614:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
 619:	64 48 33 04 25 28 00 00 00 	xor    rax,QWORD PTR fs:0x28
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        vol_a[i] = 7;
    }
    return get_time() - elapsed;
 622:	f2 0f 5c 44 24 08    	subsd  xmm0,QWORD PTR [rsp+0x8]
}
 628:	75 06                	jne    630 <w_seq_fill()+0x60>
 62a:	48 83 c4 20          	add    rsp,0x20
 62e:	5b                   	pop    rbx
 62f:	c3                   	ret    
 630:	e8 00 00 00 00       	call   635 <w_seq_fill()+0x65>	631: R_X86_64_PC32	__stack_chk_fail-0x4
 635:	90                   	nop
 636:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

0000000000000640 <w_rand_ind()>:

double w_rand_ind(){
 640:	53                   	push   rbx
 641:	48 83 ec 20          	sub    rsp,0x20
    volatile data_t * vol_a = a;
 645:	48 8b 1d 00 00 00 00 	mov    rbx,QWORD PTR [rip+0x0]        # 64c <w_rand_ind()+0xc>	648: R_X86_64_PC32	a-0x4
        vol_a[i] = 7;
    }
    return get_time() - elapsed;
}

double w_rand_ind(){
 64c:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 655:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
 65a:	31 c0                	xor    eax,eax
    volatile data_t * vol_a = a;
    double elapsed = get_time();
 65c:	e8 00 00 00 00       	call   661 <w_rand_ind()+0x21>	65d: R_X86_64_PC32	get_time()-0x4
 661:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
 666:	31 c9                	xor    ecx,ecx
 668:	31 d2                	xor    edx,edx
 66a:	bf 00 00 00 00       	mov    edi,0x0	66b: R_X86_64_32	.text+0xc0
 66f:	f2 0f 11 44 24 08    	movsd  QWORD PTR [rsp+0x8],xmm0
    #pragma omp parallel for
 675:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
 67a:	e8 00 00 00 00       	call   67f <w_rand_ind()+0x3f>	67b: R_X86_64_PC32	GOMP_parallel-0x4
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        uint64_t idx = ((i * 0xDEADBEEF) ^ 0xC0FFEE0B) % HS_ARRAY_ELEM;
        vol_a[idx] = 7;
    }
    return get_time() - elapsed;
 67f:	e8 00 00 00 00       	call   684 <w_rand_ind()+0x44>	680: R_X86_64_PC32	get_time()-0x4
}
 684:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
 689:	64 48 33 04 25 28 00 00 00 	xor    rax,QWORD PTR fs:0x28
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        uint64_t idx = ((i * 0xDEADBEEF) ^ 0xC0FFEE0B) % HS_ARRAY_ELEM;
        vol_a[idx] = 7;
    }
    return get_time() - elapsed;
 692:	f2 0f 5c 44 24 08    	subsd  xmm0,QWORD PTR [rsp+0x8]
}
 698:	75 06                	jne    6a0 <w_rand_ind()+0x60>
 69a:	48 83 c4 20          	add    rsp,0x20
 69e:	5b                   	pop    rbx
 69f:	c3                   	ret    
 6a0:	e8 00 00 00 00       	call   6a5 <w_rand_ind()+0x65>	6a1: R_X86_64_PC32	__stack_chk_fail-0x4
 6a5:	90                   	nop
 6a6:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

00000000000006b0 <w_stride_2()>:

double w_stride_2(){
 6b0:	48 83 ec 18          	sub    rsp,0x18
    double elapsed = get_time();
 6b4:	e8 00 00 00 00       	call   6b9 <w_stride_2()+0x9>	6b5: R_X86_64_PC32	get_time()-0x4
 6b9:	31 c9                	xor    ecx,ecx
 6bb:	31 d2                	xor    edx,edx
 6bd:	31 f6                	xor    esi,esi
 6bf:	bf 00 00 00 00       	mov    edi,0x0	6c0: R_X86_64_32	.text+0x140
 6c4:	f2 0f 11 44 24 08    	movsd  QWORD PTR [rsp+0x8],xmm0
 6ca:	e8 00 00 00 00       	call   6cf <w_stride_2()+0x1f>	6cb: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 2) {
        a[i] = 7;
    }
    return get_time() - elapsed;
 6cf:	e8 00 00 00 00       	call   6d4 <w_stride_2()+0x24>	6d0: R_X86_64_PC32	get_time()-0x4
 6d4:	f2 0f 5c 44 24 08    	subsd  xmm0,QWORD PTR [rsp+0x8]
}
 6da:	48 83 c4 18          	add    rsp,0x18
 6de:	c3                   	ret    
 6df:	90                   	nop

00000000000006e0 <w_stride_4()>:

double w_stride_4(){
 6e0:	48 83 ec 18          	sub    rsp,0x18
    double elapsed = get_time();
 6e4:	e8 00 00 00 00       	call   6e9 <w_stride_4()+0x9>	6e5: R_X86_64_PC32	get_time()-0x4
 6e9:	31 c9                	xor    ecx,ecx
 6eb:	31 d2                	xor    edx,edx
 6ed:	31 f6                	xor    esi,esi
 6ef:	bf 00 00 00 00       	mov    edi,0x0	6f0: R_X86_64_32	.text+0x1a0
 6f4:	f2 0f 11 44 24 08    	movsd  QWORD PTR [rsp+0x8],xmm0
 6fa:	e8 00 00 00 00       	call   6ff <w_stride_4()+0x1f>	6fb: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 4) {
        a[i] = 7;
    }
    return get_time() - elapsed;
 6ff:	e8 00 00 00 00       	call   704 <w_stride_4()+0x24>	700: R_X86_64_PC32	get_time()-0x4
 704:	f2 0f 5c 44 24 08    	subsd  xmm0,QWORD PTR [rsp+0x8]
}
 70a:	48 83 c4 18          	add    rsp,0x18
 70e:	c3                   	ret    
 70f:	90                   	nop

0000000000000710 <w_stride_8()>:

double w_stride_8(){
 710:	48 83 ec 18          	sub    rsp,0x18
    double elapsed = get_time();
 714:	e8 00 00 00 00       	call   719 <w_stride_8()+0x9>	715: R_X86_64_PC32	get_time()-0x4
 719:	31 c9                	xor    ecx,ecx
 71b:	31 d2                	xor    edx,edx
 71d:	31 f6                	xor    esi,esi
 71f:	bf 00 00 00 00       	mov    edi,0x0	720: R_X86_64_32	.text+0x200
 724:	f2 0f 11 44 24 08    	movsd  QWORD PTR [rsp+0x8],xmm0
 72a:	e8 00 00 00 00       	call   72f <w_stride_8()+0x1f>	72b: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 8) {
        a[i] = 7;
    }
    return get_time() - elapsed;
 72f:	e8 00 00 00 00       	call   734 <w_stride_8()+0x24>	730: R_X86_64_PC32	get_time()-0x4
 734:	f2 0f 5c 44 24 08    	subsd  xmm0,QWORD PTR [rsp+0x8]
}
 73a:	48 83 c4 18          	add    rsp,0x18
 73e:	c3                   	ret    
 73f:	90                   	nop

0000000000000740 <w_stride_16()>:

double w_stride_16(){
 740:	48 83 ec 18          	sub    rsp,0x18
    double elapsed = get_time();
 744:	e8 00 00 00 00       	call   749 <w_stride_16()+0x9>	745: R_X86_64_PC32	get_time()-0x4
 749:	31 c9                	xor    ecx,ecx
 74b:	31 d2                	xor    edx,edx
 74d:	31 f6                	xor    esi,esi
 74f:	bf 00 00 00 00       	mov    edi,0x0	750: R_X86_64_32	.text+0x260
 754:	f2 0f 11 44 24 08    	movsd  QWORD PTR [rsp+0x8],xmm0
 75a:	e8 00 00 00 00       	call   75f <w_stride_16()+0x1f>	75b: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 16) {
        a[i] = 7;
    }
    return get_time() - elapsed;
 75f:	e8 00 00 00 00       	call   764 <w_stride_16()+0x24>	760: R_X86_64_PC32	get_time()-0x4
 764:	f2 0f 5c 44 24 08    	subsd  xmm0,QWORD PTR [rsp+0x8]
}
 76a:	48 83 c4 18          	add    rsp,0x18
 76e:	c3                   	ret    
 76f:	90                   	nop

0000000000000770 <w_stride_32()>:

double w_stride_32(){
 770:	48 83 ec 18          	sub    rsp,0x18
    double elapsed = get_time();
 774:	e8 00 00 00 00       	call   779 <w_stride_32()+0x9>	775: R_X86_64_PC32	get_time()-0x4
 779:	31 c9                	xor    ecx,ecx
 77b:	31 d2                	xor    edx,edx
 77d:	31 f6                	xor    esi,esi
 77f:	bf 00 00 00 00       	mov    edi,0x0	780: R_X86_64_32	.text+0x2c0
 784:	f2 0f 11 44 24 08    	movsd  QWORD PTR [rsp+0x8],xmm0
 78a:	e8 00 00 00 00       	call   78f <w_stride_32()+0x1f>	78b: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 32) {
        a[i] = 7;
    }
    return get_time() - elapsed;
 78f:	e8 00 00 00 00       	call   794 <w_stride_32()+0x24>	790: R_X86_64_PC32	get_time()-0x4
 794:	f2 0f 5c 44 24 08    	subsd  xmm0,QWORD PTR [rsp+0x8]
}
 79a:	48 83 c4 18          	add    rsp,0x18
 79e:	c3                   	ret    
 79f:	90                   	nop

00000000000007a0 <w_tile(unsigned long, unsigned long)>:

double w_tile(uint64_t L, uint64_t K){
 7a0:	55                   	push   rbp
 7a1:	53                   	push   rbx
 7a2:	48 89 fd             	mov    rbp,rdi
 7a5:	48 89 f3             	mov    rbx,rsi
 7a8:	48 83 ec 38          	sub    rsp,0x38
 7ac:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 7b5:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
 7ba:	31 c0                	xor    eax,eax
//double w_tile(){
    double elapsed = get_time();
 7bc:	e8 00 00 00 00       	call   7c1 <w_tile(unsigned long, unsigned long)+0x21>	7bd: R_X86_64_PC32	get_time()-0x4
 7c1:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
 7c6:	31 c9                	xor    ecx,ecx
 7c8:	31 d2                	xor    edx,edx
 7ca:	bf 00 00 00 00       	mov    edi,0x0	7cb: R_X86_64_32	.text+0x320
 7cf:	f2 0f 11 44 24 08    	movsd  QWORD PTR [rsp+0x8],xmm0
    #pragma omp parallel for
 7d5:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
 7da:	48 89 5c 24 18       	mov    QWORD PTR [rsp+0x18],rbx
 7df:	e8 00 00 00 00       	call   7e4 <w_tile(unsigned long, unsigned long)+0x44>	7e0: R_X86_64_PC32	GOMP_parallel-0x4
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
            a[i+j] = 7;
        }
    }
    return get_time() - elapsed;
 7e4:	e8 00 00 00 00       	call   7e9 <w_tile(unsigned long, unsigned long)+0x49>	7e5: R_X86_64_PC32	get_time()-0x4
}
 7e9:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
 7ee:	64 48 33 04 25 28 00 00 00 	xor    rax,QWORD PTR fs:0x28
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
            a[i+j] = 7;
        }
    }
    return get_time() - elapsed;
 7f7:	f2 0f 5c 44 24 08    	subsd  xmm0,QWORD PTR [rsp+0x8]
}
 7fd:	75 07                	jne    806 <w_tile(unsigned long, unsigned long)+0x66>
 7ff:	48 83 c4 38          	add    rsp,0x38
 803:	5b                   	pop    rbx
 804:	5d                   	pop    rbp
 805:	c3                   	ret    
 806:	e8 00 00 00 00       	call   80b <w_tile(unsigned long, unsigned long)+0x6b>	807: R_X86_64_PC32	__stack_chk_fail-0x4
 80b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000000810 <w_dma(unsigned long**, unsigned long*, unsigned long)>:

double w_dma(data_t** addr, uint64_t* len, uint64_t count) {
 810:	41 54                	push   r12
 812:	55                   	push   rbp
 813:	49 89 fc             	mov    r12,rdi
 816:	53                   	push   rbx
 817:	48 89 f5             	mov    rbp,rsi
 81a:	48 89 d3             	mov    rbx,rdx
 81d:	48 83 ec 30          	sub    rsp,0x30
 821:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 82a:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
 82f:	31 c0                	xor    eax,eax
    double elapsed = get_time();
 831:	e8 00 00 00 00       	call   836 <w_dma(unsigned long**, unsigned long*, unsigned long)+0x26>	832: R_X86_64_PC32	get_time()-0x4
 836:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
 83b:	31 c9                	xor    ecx,ecx
 83d:	31 d2                	xor    edx,edx
 83f:	bf 00 00 00 00       	mov    edi,0x0	840: R_X86_64_32	.text+0x3c0
 844:	f2 0f 11 44 24 08    	movsd  QWORD PTR [rsp+0x8],xmm0
    #pragma omp parallel for
 84a:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
 84f:	48 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],rbp
 854:	48 89 5c 24 20       	mov    QWORD PTR [rsp+0x20],rbx
 859:	e8 00 00 00 00       	call   85e <w_dma(unsigned long**, unsigned long*, unsigned long)+0x4e>	85a: R_X86_64_PC32	GOMP_parallel-0x4
        data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
            *c_addr++ = 7;
        }
    }
    return get_time() - elapsed;
 85e:	e8 00 00 00 00       	call   863 <w_dma(unsigned long**, unsigned long*, unsigned long)+0x53>	85f: R_X86_64_PC32	get_time()-0x4
}
 863:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
 868:	64 48 33 04 25 28 00 00 00 	xor    rax,QWORD PTR fs:0x28
        data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
            *c_addr++ = 7;
        }
    }
    return get_time() - elapsed;
 871:	f2 0f 5c 44 24 08    	subsd  xmm0,QWORD PTR [rsp+0x8]
}
 877:	75 09                	jne    882 <w_dma(unsigned long**, unsigned long*, unsigned long)+0x72>
 879:	48 83 c4 30          	add    rsp,0x30
 87d:	5b                   	pop    rbx
 87e:	5d                   	pop    rbp
 87f:	41 5c                	pop    r12
 881:	c3                   	ret    
 882:	e8 00 00 00 00       	call   887 <w_dma(unsigned long**, unsigned long*, unsigned long)+0x77>	883: R_X86_64_PC32	__stack_chk_fail-0x4
