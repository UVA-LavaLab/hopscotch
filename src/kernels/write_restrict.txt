
write_kernels.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <w_seq_memset() [clone ._omp_fn.0]>:
using namespace std;

double w_seq_memset(){
    volatile data_t* vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel
   0:	53                   	push   rbx
    {
        uint64_t tid = omp_get_thread_num();
   1:	e8 00 00 00 00       	call   6 <w_seq_memset() [clone ._omp_fn.0]+0x6>	2: R_X86_64_PC32	omp_get_thread_num-0x4
   6:	89 c3                	mov    ebx,eax
        uint64_t elem_per_thread = HS_ARRAY_ELEM / omp_get_num_threads();
   8:	e8 00 00 00 00       	call   d <w_seq_memset() [clone ._omp_fn.0]+0xd>	9: R_X86_64_PC32	omp_get_num_threads-0x4
   d:	31 d2                	xor    edx,edx
   f:	48 63 c8             	movsxd rcx,eax
  12:	b8 00 00 00 04       	mov    eax,0x4000000
  17:	48 f7 f1             	div    rcx
    {
      __warn_memset_zero_len ();
      return __dest;
    }
#endif
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
  1a:	48 63 fb             	movsxd rdi,ebx
  1d:	be 07 00 00 00       	mov    esi,0x7
  22:	48 c1 e7 03          	shl    rdi,0x3
using namespace std;

double w_seq_memset(){
    volatile data_t* vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel
  26:	5b                   	pop    rbx
  27:	48 8d 14 c5 00 00 00 00 	lea    rdx,[rax*8+0x0]
  2f:	48 0f af c7          	imul   rax,rdi
  33:	48 03 05 00 00 00 00 	add    rax,QWORD PTR [rip+0x0]        # 3a <w_seq_memset() [clone ._omp_fn.0]+0x3a>	36: R_X86_64_PC32	a-0x4
  3a:	48 89 c7             	mov    rdi,rax
  3d:	e9 00 00 00 00       	jmp    42 <w_seq_memset() [clone ._omp_fn.0]+0x42>	3e: R_X86_64_PC32	memset-0x4
  42:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  46:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

0000000000000050 <w_seq_fill() [clone ._omp_fn.1]>:
}

double w_seq_fill(){
    //volatile data_t* vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
  50:	55                   	push   rbp
  51:	48 89 e5             	mov    rbp,rsp
  54:	41 52                	push   r10
  56:	53                   	push   rbx
  57:	e8 00 00 00 00       	call   5c <w_seq_fill() [clone ._omp_fn.1]+0xc>	58: R_X86_64_PC32	omp_get_num_threads-0x4
  5c:	48 63 d8             	movsxd rbx,eax
  5f:	e8 00 00 00 00       	call   64 <w_seq_fill() [clone ._omp_fn.1]+0x14>	60: R_X86_64_PC32	omp_get_thread_num-0x4
  64:	31 d2                	xor    edx,edx
  66:	48 63 c8             	movsxd rcx,eax
  69:	b8 00 00 00 04       	mov    eax,0x4000000
  6e:	48 f7 f3             	div    rbx
  71:	48 39 d1             	cmp    rcx,rdx
  74:	73 06                	jae    7c <w_seq_fill() [clone ._omp_fn.1]+0x2c>
  76:	48 83 c0 01          	add    rax,0x1
  7a:	31 d2                	xor    edx,edx
  7c:	48 0f af c8          	imul   rcx,rax
  80:	48 01 ca             	add    rdx,rcx
  83:	4c 8d 0c 10          	lea    r9,[rax+rdx*1]
  87:	4c 39 ca             	cmp    rdx,r9
  8a:	0f 83 1b 01 00 00    	jae    1ab <w_seq_fill() [clone ._omp_fn.1]+0x15b>
  90:	48 8b 3d 00 00 00 00 	mov    rdi,QWORD PTR [rip+0x0]        # 97 <w_seq_fill() [clone ._omp_fn.1]+0x47>	93: R_X86_64_PC32	a-0x4
  97:	48 8d 34 d7          	lea    rsi,[rdi+rdx*8]
  9b:	48 89 f1             	mov    rcx,rsi
  9e:	83 e1 1f             	and    ecx,0x1f
  a1:	48 c1 e9 03          	shr    rcx,0x3
  a5:	48 f7 d9             	neg    rcx
  a8:	83 e1 03             	and    ecx,0x3
  ab:	48 39 c1             	cmp    rcx,rax
  ae:	48 0f 47 c8          	cmova  rcx,rax
  b2:	48 83 f8 06          	cmp    rax,0x6
  b6:	48 0f 46 c8          	cmovbe rcx,rax
  ba:	48 85 c9             	test   rcx,rcx
  bd:	0f 84 ed 00 00 00    	je     1b0 <w_seq_fill() [clone ._omp_fn.1]+0x160>
  c3:	48 83 f9 01          	cmp    rcx,0x1
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        a[i] = 7;
  c7:	48 c7 06 07 00 00 00 	mov    QWORD PTR [rsi],0x7
  ce:	48 8d 72 01          	lea    rsi,[rdx+0x1]
  d2:	74 54                	je     128 <w_seq_fill() [clone ._omp_fn.1]+0xd8>
  d4:	48 83 f9 02          	cmp    rcx,0x2
  d8:	48 c7 04 f7 07 00 00 00 	mov    QWORD PTR [rdi+rsi*8],0x7
  e0:	48 8d 72 02          	lea    rsi,[rdx+0x2]
  e4:	74 42                	je     128 <w_seq_fill() [clone ._omp_fn.1]+0xd8>
  e6:	48 83 f9 03          	cmp    rcx,0x3
  ea:	48 c7 04 f7 07 00 00 00 	mov    QWORD PTR [rdi+rsi*8],0x7
  f2:	48 8d 72 03          	lea    rsi,[rdx+0x3]
  f6:	74 30                	je     128 <w_seq_fill() [clone ._omp_fn.1]+0xd8>
  f8:	48 83 f9 04          	cmp    rcx,0x4
  fc:	48 c7 04 f7 07 00 00 00 	mov    QWORD PTR [rdi+rsi*8],0x7
 104:	48 8d 72 04          	lea    rsi,[rdx+0x4]
 108:	74 1e                	je     128 <w_seq_fill() [clone ._omp_fn.1]+0xd8>
 10a:	48 83 f9 06          	cmp    rcx,0x6
 10e:	48 c7 04 f7 07 00 00 00 	mov    QWORD PTR [rdi+rsi*8],0x7
 116:	48 8d 72 05          	lea    rsi,[rdx+0x5]
 11a:	75 0c                	jne    128 <w_seq_fill() [clone ._omp_fn.1]+0xd8>
 11c:	48 c7 04 f7 07 00 00 00 	mov    QWORD PTR [rdi+rsi*8],0x7
 124:	48 8d 72 06          	lea    rsi,[rdx+0x6]
 128:	48 39 c8             	cmp    rax,rcx
 12b:	74 7e                	je     1ab <w_seq_fill() [clone ._omp_fn.1]+0x15b>
 12d:	49 89 c2             	mov    r10,rax
 130:	48 83 e8 01          	sub    rax,0x1
 134:	49 29 ca             	sub    r10,rcx
 137:	48 29 c8             	sub    rax,rcx
 13a:	4d 8d 42 fc          	lea    r8,[r10-0x4]
 13e:	49 c1 e8 02          	shr    r8,0x2
 142:	49 83 c0 01          	add    r8,0x1
 146:	48 83 f8 02          	cmp    rax,0x2
 14a:	4e 8d 1c 85 00 00 00 00 	lea    r11,[r8*4+0x0]
 152:	76 2d                	jbe    181 <w_seq_fill() [clone ._omp_fn.1]+0x131>
 154:	48 01 ca             	add    rdx,rcx
 157:	c5 fd 6f 05 00 00 00 00 	vmovdqa ymm0,YMMWORD PTR [rip+0x0]        # 15f <w_seq_fill() [clone ._omp_fn.1]+0x10f>	15b: R_X86_64_PC32	.LC1-0x4
}

double w_seq_fill(){
    //volatile data_t* vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 15f:	31 c0                	xor    eax,eax
 161:	48 8d 14 d7          	lea    rdx,[rdi+rdx*8]
 165:	48 83 c0 01          	add    rax,0x1
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        a[i] = 7;
 169:	c5 fd 7f 02          	vmovdqa YMMWORD PTR [rdx],ymm0
 16d:	48 83 c2 20          	add    rdx,0x20
 171:	49 39 c0             	cmp    r8,rax
 174:	77 ef                	ja     165 <w_seq_fill() [clone ._omp_fn.1]+0x115>
 176:	4c 01 de             	add    rsi,r11
 179:	4d 39 da             	cmp    r10,r11
 17c:	74 42                	je     1c0 <w_seq_fill() [clone ._omp_fn.1]+0x170>
 17e:	c5 f8 77             	vzeroupper 
 181:	48 8d 46 01          	lea    rax,[rsi+0x1]
 185:	48 c7 04 f7 07 00 00 00 	mov    QWORD PTR [rdi+rsi*8],0x7
 18d:	4c 39 c8             	cmp    rax,r9
 190:	73 19                	jae    1ab <w_seq_fill() [clone ._omp_fn.1]+0x15b>
 192:	48 83 c6 02          	add    rsi,0x2
 196:	48 c7 04 c7 07 00 00 00 	mov    QWORD PTR [rdi+rax*8],0x7
 19e:	49 39 f1             	cmp    r9,rsi
 1a1:	76 08                	jbe    1ab <w_seq_fill() [clone ._omp_fn.1]+0x15b>
 1a3:	48 c7 04 f7 07 00 00 00 	mov    QWORD PTR [rdi+rsi*8],0x7
}

double w_seq_fill(){
    //volatile data_t* vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 1ab:	5b                   	pop    rbx
 1ac:	41 5a                	pop    r10
 1ae:	5d                   	pop    rbp
 1af:	c3                   	ret    
 1b0:	48 89 d6             	mov    rsi,rdx
 1b3:	e9 75 ff ff ff       	jmp    12d <w_seq_fill() [clone ._omp_fn.1]+0xdd>
 1b8:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
 1c0:	c5 f8 77             	vzeroupper 
 1c3:	5b                   	pop    rbx
 1c4:	41 5a                	pop    r10
 1c6:	5d                   	pop    rbp
 1c7:	c3                   	ret    
 1c8:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]

00000000000001d0 <w_rand_ind() [clone ._omp_fn.2]>:
}

double w_rand_ind(){
    //volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 1d0:	53                   	push   rbx
 1d1:	e8 00 00 00 00       	call   1d6 <w_rand_ind() [clone ._omp_fn.2]+0x6>	1d2: R_X86_64_PC32	omp_get_num_threads-0x4
 1d6:	48 63 d8             	movsxd rbx,eax
 1d9:	e8 00 00 00 00       	call   1de <w_rand_ind() [clone ._omp_fn.2]+0xe>	1da: R_X86_64_PC32	omp_get_thread_num-0x4
 1de:	31 d2                	xor    edx,edx
 1e0:	48 63 c8             	movsxd rcx,eax
 1e3:	b8 00 00 00 04       	mov    eax,0x4000000
 1e8:	48 f7 f3             	div    rbx
 1eb:	48 39 d1             	cmp    rcx,rdx
 1ee:	73 06                	jae    1f6 <w_rand_ind() [clone ._omp_fn.2]+0x26>
 1f0:	48 83 c0 01          	add    rax,0x1
 1f4:	31 d2                	xor    edx,edx
 1f6:	48 0f af c8          	imul   rcx,rax
 1fa:	48 01 ca             	add    rdx,rcx
 1fd:	48 01 d0             	add    rax,rdx
 200:	48 39 c2             	cmp    rdx,rax
 203:	73 37                	jae    23c <w_rand_ind() [clone ._omp_fn.2]+0x6c>
 205:	be ef be ad de       	mov    esi,0xdeadbeef
 20a:	4c 8b 05 00 00 00 00 	mov    r8,QWORD PTR [rip+0x0]        # 211 <w_rand_ind() [clone ._omp_fn.2]+0x41>	20d: R_X86_64_PC32	a-0x4
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        uint64_t idx = ((i * 0xDEADBEEF) ^ 0xC0FFEE0B) % HS_ARRAY_ELEM;
        a[idx] = 7;
 211:	bf 0b ee ff c0       	mov    edi,0xc0ffee0b
 216:	48 0f af d6          	imul   rdx,rsi
 21a:	48 0f af c6          	imul   rax,rsi
 21e:	66 90                	xchg   ax,ax
 220:	48 89 d1             	mov    rcx,rdx
 223:	48 01 f2             	add    rdx,rsi
 226:	48 31 f9             	xor    rcx,rdi
 229:	81 e1 ff ff ff 03    	and    ecx,0x3ffffff
 22f:	48 39 d0             	cmp    rax,rdx
 232:	49 c7 04 c8 07 00 00 00 	mov    QWORD PTR [r8+rcx*8],0x7
 23a:	75 e4                	jne    220 <w_rand_ind() [clone ._omp_fn.2]+0x50>
}

double w_rand_ind(){
    //volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 23c:	5b                   	pop    rbx
 23d:	c3                   	ret    
 23e:	66 90                	xchg   ax,ax

0000000000000240 <w_stride_2() [clone ._omp_fn.3]>:
    return get_time() - elapsed;
}

double w_stride_2(){
    double elapsed = get_time();
    #pragma omp parallel for
 240:	53                   	push   rbx
 241:	e8 00 00 00 00       	call   246 <w_stride_2() [clone ._omp_fn.3]+0x6>	242: R_X86_64_PC32	omp_get_num_threads-0x4
 246:	48 63 d8             	movsxd rbx,eax
 249:	e8 00 00 00 00       	call   24e <w_stride_2() [clone ._omp_fn.3]+0xe>	24a: R_X86_64_PC32	omp_get_thread_num-0x4
 24e:	31 d2                	xor    edx,edx
 250:	48 63 c8             	movsxd rcx,eax
 253:	b8 00 00 00 02       	mov    eax,0x2000000
 258:	48 f7 f3             	div    rbx
 25b:	48 39 d1             	cmp    rcx,rdx
 25e:	73 06                	jae    266 <w_stride_2() [clone ._omp_fn.3]+0x26>
 260:	48 83 c0 01          	add    rax,0x1
 264:	31 d2                	xor    edx,edx
 266:	48 0f af c8          	imul   rcx,rax
 26a:	48 01 ca             	add    rdx,rcx
 26d:	48 01 d0             	add    rax,rdx
 270:	48 39 c2             	cmp    rdx,rax
 273:	73 24                	jae    299 <w_stride_2() [clone ._omp_fn.3]+0x59>
 275:	48 8b 0d 00 00 00 00 	mov    rcx,QWORD PTR [rip+0x0]        # 27c <w_stride_2() [clone ._omp_fn.3]+0x3c>	278: R_X86_64_PC32	a-0x4
 27c:	48 01 d2             	add    rdx,rdx
 27f:	48 01 c0             	add    rax,rax
 282:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 2) {
        a[i] = 7;
 288:	48 c7 04 d1 07 00 00 00 	mov    QWORD PTR [rcx+rdx*8],0x7
 290:	48 83 c2 02          	add    rdx,0x2
 294:	48 39 d0             	cmp    rax,rdx
 297:	77 ef                	ja     288 <w_stride_2() [clone ._omp_fn.3]+0x48>
    return get_time() - elapsed;
}

double w_stride_2(){
    double elapsed = get_time();
    #pragma omp parallel for
 299:	5b                   	pop    rbx
 29a:	c3                   	ret    
 29b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000000002a0 <w_stride_4() [clone ._omp_fn.4]>:
    return get_time() - elapsed;
}

double w_stride_4(){
    double elapsed = get_time();
    #pragma omp parallel for
 2a0:	53                   	push   rbx
 2a1:	e8 00 00 00 00       	call   2a6 <w_stride_4() [clone ._omp_fn.4]+0x6>	2a2: R_X86_64_PC32	omp_get_num_threads-0x4
 2a6:	48 63 d8             	movsxd rbx,eax
 2a9:	e8 00 00 00 00       	call   2ae <w_stride_4() [clone ._omp_fn.4]+0xe>	2aa: R_X86_64_PC32	omp_get_thread_num-0x4
 2ae:	31 d2                	xor    edx,edx
 2b0:	48 63 c8             	movsxd rcx,eax
 2b3:	b8 00 00 00 01       	mov    eax,0x1000000
 2b8:	48 f7 f3             	div    rbx
 2bb:	48 39 d1             	cmp    rcx,rdx
 2be:	73 06                	jae    2c6 <w_stride_4() [clone ._omp_fn.4]+0x26>
 2c0:	48 83 c0 01          	add    rax,0x1
 2c4:	31 d2                	xor    edx,edx
 2c6:	48 0f af c8          	imul   rcx,rax
 2ca:	48 01 ca             	add    rdx,rcx
 2cd:	48 01 d0             	add    rax,rdx
 2d0:	48 39 c2             	cmp    rdx,rax
 2d3:	73 24                	jae    2f9 <w_stride_4() [clone ._omp_fn.4]+0x59>
 2d5:	48 8b 0d 00 00 00 00 	mov    rcx,QWORD PTR [rip+0x0]        # 2dc <w_stride_4() [clone ._omp_fn.4]+0x3c>	2d8: R_X86_64_PC32	a-0x4
 2dc:	48 c1 e2 02          	shl    rdx,0x2
 2e0:	48 c1 e0 02          	shl    rax,0x2
 2e4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 4) {
        a[i] = 7;
 2e8:	48 c7 04 d1 07 00 00 00 	mov    QWORD PTR [rcx+rdx*8],0x7
 2f0:	48 83 c2 04          	add    rdx,0x4
 2f4:	48 39 d0             	cmp    rax,rdx
 2f7:	77 ef                	ja     2e8 <w_stride_4() [clone ._omp_fn.4]+0x48>
    return get_time() - elapsed;
}

double w_stride_4(){
    double elapsed = get_time();
    #pragma omp parallel for
 2f9:	5b                   	pop    rbx
 2fa:	c3                   	ret    
 2fb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000000300 <w_stride_8() [clone ._omp_fn.5]>:
    return get_time() - elapsed;
}

double w_stride_8(){
    double elapsed = get_time();
    #pragma omp parallel for
 300:	53                   	push   rbx
 301:	e8 00 00 00 00       	call   306 <w_stride_8() [clone ._omp_fn.5]+0x6>	302: R_X86_64_PC32	omp_get_num_threads-0x4
 306:	48 63 d8             	movsxd rbx,eax
 309:	e8 00 00 00 00       	call   30e <w_stride_8() [clone ._omp_fn.5]+0xe>	30a: R_X86_64_PC32	omp_get_thread_num-0x4
 30e:	31 d2                	xor    edx,edx
 310:	48 63 c8             	movsxd rcx,eax
 313:	b8 00 00 80 00       	mov    eax,0x800000
 318:	48 f7 f3             	div    rbx
 31b:	48 39 d1             	cmp    rcx,rdx
 31e:	73 06                	jae    326 <w_stride_8() [clone ._omp_fn.5]+0x26>
 320:	48 83 c0 01          	add    rax,0x1
 324:	31 d2                	xor    edx,edx
 326:	48 0f af c8          	imul   rcx,rax
 32a:	48 01 ca             	add    rdx,rcx
 32d:	48 01 d0             	add    rax,rdx
 330:	48 39 c2             	cmp    rdx,rax
 333:	73 24                	jae    359 <w_stride_8() [clone ._omp_fn.5]+0x59>
 335:	48 8b 0d 00 00 00 00 	mov    rcx,QWORD PTR [rip+0x0]        # 33c <w_stride_8() [clone ._omp_fn.5]+0x3c>	338: R_X86_64_PC32	a-0x4
 33c:	48 c1 e2 03          	shl    rdx,0x3
 340:	48 c1 e0 03          	shl    rax,0x3
 344:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 8) {
        a[i] = 7;
 348:	48 c7 04 d1 07 00 00 00 	mov    QWORD PTR [rcx+rdx*8],0x7
 350:	48 83 c2 08          	add    rdx,0x8
 354:	48 39 d0             	cmp    rax,rdx
 357:	77 ef                	ja     348 <w_stride_8() [clone ._omp_fn.5]+0x48>
    return get_time() - elapsed;
}

double w_stride_8(){
    double elapsed = get_time();
    #pragma omp parallel for
 359:	5b                   	pop    rbx
 35a:	c3                   	ret    
 35b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000000360 <w_stride_16() [clone ._omp_fn.6]>:
    return get_time() - elapsed;
}

double w_stride_16(){
    double elapsed = get_time();
    #pragma omp parallel for
 360:	53                   	push   rbx
 361:	e8 00 00 00 00       	call   366 <w_stride_16() [clone ._omp_fn.6]+0x6>	362: R_X86_64_PC32	omp_get_num_threads-0x4
 366:	48 63 d8             	movsxd rbx,eax
 369:	e8 00 00 00 00       	call   36e <w_stride_16() [clone ._omp_fn.6]+0xe>	36a: R_X86_64_PC32	omp_get_thread_num-0x4
 36e:	31 d2                	xor    edx,edx
 370:	48 63 c8             	movsxd rcx,eax
 373:	b8 00 00 40 00       	mov    eax,0x400000
 378:	48 f7 f3             	div    rbx
 37b:	48 39 d1             	cmp    rcx,rdx
 37e:	73 06                	jae    386 <w_stride_16() [clone ._omp_fn.6]+0x26>
 380:	48 83 c0 01          	add    rax,0x1
 384:	31 d2                	xor    edx,edx
 386:	48 0f af c8          	imul   rcx,rax
 38a:	48 01 ca             	add    rdx,rcx
 38d:	48 01 d0             	add    rax,rdx
 390:	48 39 c2             	cmp    rdx,rax
 393:	73 24                	jae    3b9 <w_stride_16() [clone ._omp_fn.6]+0x59>
 395:	48 8b 0d 00 00 00 00 	mov    rcx,QWORD PTR [rip+0x0]        # 39c <w_stride_16() [clone ._omp_fn.6]+0x3c>	398: R_X86_64_PC32	a-0x4
 39c:	48 c1 e2 04          	shl    rdx,0x4
 3a0:	48 c1 e0 04          	shl    rax,0x4
 3a4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 16) {
        a[i] = 7;
 3a8:	48 c7 04 d1 07 00 00 00 	mov    QWORD PTR [rcx+rdx*8],0x7
 3b0:	48 83 c2 10          	add    rdx,0x10
 3b4:	48 39 d0             	cmp    rax,rdx
 3b7:	77 ef                	ja     3a8 <w_stride_16() [clone ._omp_fn.6]+0x48>
    return get_time() - elapsed;
}

double w_stride_16(){
    double elapsed = get_time();
    #pragma omp parallel for
 3b9:	5b                   	pop    rbx
 3ba:	c3                   	ret    
 3bb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000000003c0 <w_stride_32() [clone ._omp_fn.7]>:
    return get_time() - elapsed;
}

double w_stride_32(){
    double elapsed = get_time();
    #pragma omp parallel for
 3c0:	53                   	push   rbx
 3c1:	e8 00 00 00 00       	call   3c6 <w_stride_32() [clone ._omp_fn.7]+0x6>	3c2: R_X86_64_PC32	omp_get_num_threads-0x4
 3c6:	48 63 d8             	movsxd rbx,eax
 3c9:	e8 00 00 00 00       	call   3ce <w_stride_32() [clone ._omp_fn.7]+0xe>	3ca: R_X86_64_PC32	omp_get_thread_num-0x4
 3ce:	31 d2                	xor    edx,edx
 3d0:	48 63 c8             	movsxd rcx,eax
 3d3:	b8 00 00 20 00       	mov    eax,0x200000
 3d8:	48 f7 f3             	div    rbx
 3db:	48 39 d1             	cmp    rcx,rdx
 3de:	73 06                	jae    3e6 <w_stride_32() [clone ._omp_fn.7]+0x26>
 3e0:	48 83 c0 01          	add    rax,0x1
 3e4:	31 d2                	xor    edx,edx
 3e6:	48 0f af c8          	imul   rcx,rax
 3ea:	48 01 ca             	add    rdx,rcx
 3ed:	48 01 d0             	add    rax,rdx
 3f0:	48 39 c2             	cmp    rdx,rax
 3f3:	73 24                	jae    419 <w_stride_32() [clone ._omp_fn.7]+0x59>
 3f5:	48 8b 0d 00 00 00 00 	mov    rcx,QWORD PTR [rip+0x0]        # 3fc <w_stride_32() [clone ._omp_fn.7]+0x3c>	3f8: R_X86_64_PC32	a-0x4
 3fc:	48 c1 e2 05          	shl    rdx,0x5
 400:	48 c1 e0 05          	shl    rax,0x5
 404:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 32) {
        a[i] = 7;
 408:	48 c7 04 d1 07 00 00 00 	mov    QWORD PTR [rcx+rdx*8],0x7
 410:	48 83 c2 20          	add    rdx,0x20
 414:	48 39 d0             	cmp    rax,rdx
 417:	77 ef                	ja     408 <w_stride_32() [clone ._omp_fn.7]+0x48>
    return get_time() - elapsed;
}

double w_stride_32(){
    double elapsed = get_time();
    #pragma omp parallel for
 419:	5b                   	pop    rbx
 41a:	c3                   	ret    
 41b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000000420 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]>:
}

double w_tile(uint64_t L, uint64_t K){
//double w_tile(){
    double elapsed = get_time();
    #pragma omp parallel for
 420:	55                   	push   rbp
 421:	48 89 e5             	mov    rbp,rsp
 424:	41 57                	push   r15
 426:	41 56                	push   r14
 428:	41 55                	push   r13
 42a:	41 54                	push   r12
 42c:	49 89 fd             	mov    r13,rdi
 42f:	41 52                	push   r10
 431:	53                   	push   rbx
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
 432:	48 8b 5f 08          	mov    rbx,QWORD PTR [rdi+0x8]
 436:	e8 00 00 00 00       	call   43b <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x1b>	437: R_X86_64_PC32	omp_get_num_threads-0x4
 43b:	4c 63 e0             	movsxd r12,eax
 43e:	e8 00 00 00 00       	call   443 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x23>	43f: R_X86_64_PC32	omp_get_thread_num-0x4
 443:	48 63 f0             	movsxd rsi,eax
 446:	48 8d 83 ff ff ff 03 	lea    rax,[rbx+0x3ffffff]
 44d:	31 d2                	xor    edx,edx
 44f:	48 f7 f3             	div    rbx
 452:	31 d2                	xor    edx,edx
 454:	49 f7 f4             	div    r12
 457:	48 39 d6             	cmp    rsi,rdx
 45a:	73 06                	jae    462 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x42>
 45c:	48 83 c0 01          	add    rax,0x1
 460:	31 d2                	xor    edx,edx
 462:	48 0f af f0          	imul   rsi,rax
 466:	48 01 d6             	add    rsi,rdx
 469:	4c 8d 04 30          	lea    r8,[rax+rsi*1]
 46d:	4c 39 c6             	cmp    rsi,r8
 470:	0f 83 6d 01 00 00    	jae    5e3 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x1c3>
 476:	48 0f af f3          	imul   rsi,rbx
 47a:	49 8b 55 00          	mov    rdx,QWORD PTR [r13+0x0]
 47e:	48 8b 3d 00 00 00 00 	mov    rdi,QWORD PTR [rip+0x0]        # 485 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x65>	481: R_X86_64_PC32	a-0x4
 485:	4c 0f af c3          	imul   r8,rbx
 489:	4c 8d 0c dd 00 00 00 00 	lea    r9,[rbx*8+0x0]
 491:	c5 fd 6f 05 00 00 00 00 	vmovdqa ymm0,YMMWORD PTR [rip+0x0]        # 499 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x79>	495: R_X86_64_PC32	.LC1-0x4
 499:	4c 8d 52 ff          	lea    r10,[rdx-0x1]
 49d:	48 8d 0c f7          	lea    rcx,[rdi+rsi*8]
 4a1:	e9 01 01 00 00       	jmp    5a7 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x187>
 4a6:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
        for(uint64_t j = 0; j < L; j++) {
 4b0:	48 89 d0             	mov    rax,rdx
 4b3:	48 83 f8 01          	cmp    rax,0x1
            a[i+j] = 7;
 4b7:	48 c7 01 07 00 00 00 	mov    QWORD PTR [rcx],0x7
 4be:	0f 84 2c 01 00 00    	je     5f0 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x1d0>
 4c4:	48 83 f8 02          	cmp    rax,0x2
 4c8:	48 c7 41 08 07 00 00 00 	mov    QWORD PTR [rcx+0x8],0x7
 4d0:	0f 84 5a 01 00 00    	je     630 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x210>
 4d6:	48 83 f8 03          	cmp    rax,0x3
 4da:	48 c7 41 10 07 00 00 00 	mov    QWORD PTR [rcx+0x10],0x7
 4e2:	0f 84 38 01 00 00    	je     620 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x200>
 4e8:	48 83 f8 04          	cmp    rax,0x4
 4ec:	48 c7 41 18 07 00 00 00 	mov    QWORD PTR [rcx+0x18],0x7
 4f4:	0f 84 16 01 00 00    	je     610 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x1f0>
 4fa:	48 83 f8 05          	cmp    rax,0x5
 4fe:	48 c7 41 20 07 00 00 00 	mov    QWORD PTR [rcx+0x20],0x7
 506:	0f 84 f4 00 00 00    	je     600 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x1e0>
 50c:	48 c7 41 28 07 00 00 00 	mov    QWORD PTR [rcx+0x28],0x7
double w_tile(uint64_t L, uint64_t K){
//double w_tile(){
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
 514:	41 bb 06 00 00 00    	mov    r11d,0x6
 51a:	48 39 c2             	cmp    rdx,rax
 51d:	74 7d                	je     59c <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x17c>
 51f:	49 89 d5             	mov    r13,rdx
 522:	4d 89 d7             	mov    r15,r10
 525:	49 29 c5             	sub    r13,rax
 528:	49 29 c7             	sub    r15,rax
 52b:	4d 8d 65 fc          	lea    r12,[r13-0x4]
 52f:	49 c1 ec 02          	shr    r12,0x2
 533:	49 83 c4 01          	add    r12,0x1
 537:	49 83 ff 02          	cmp    r15,0x2
 53b:	4e 8d 34 a5 00 00 00 00 	lea    r14,[r12*4+0x0]
 543:	76 23                	jbe    568 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x148>
 545:	48 01 f0             	add    rax,rsi
 548:	4c 8d 3c c7          	lea    r15,[rdi+rax*8]
 54c:	31 c0                	xor    eax,eax
 54e:	48 83 c0 01          	add    rax,0x1
            a[i+j] = 7;
 552:	c4 c1 7d 7f 07       	vmovdqa YMMWORD PTR [r15],ymm0
 557:	49 83 c7 20          	add    r15,0x20
 55b:	49 39 c4             	cmp    r12,rax
 55e:	77 ee                	ja     54e <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x12e>
 560:	4d 01 f3             	add    r11,r14
 563:	4d 39 f5             	cmp    r13,r14
 566:	74 34                	je     59c <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x17c>
 568:	4a 8d 04 1e          	lea    rax,[rsi+r11*1]
 56c:	48 c7 04 c7 07 00 00 00 	mov    QWORD PTR [rdi+rax*8],0x7
double w_tile(uint64_t L, uint64_t K){
//double w_tile(){
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
 574:	49 8d 43 01          	lea    rax,[r11+0x1]
 578:	48 39 d0             	cmp    rax,rdx
 57b:	73 1f                	jae    59c <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x17c>
 57d:	49 83 c3 02          	add    r11,0x2
            a[i+j] = 7;
 581:	48 01 f0             	add    rax,rsi
double w_tile(uint64_t L, uint64_t K){
//double w_tile(){
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
 584:	4c 39 da             	cmp    rdx,r11
            a[i+j] = 7;
 587:	48 c7 04 c7 07 00 00 00 	mov    QWORD PTR [rdi+rax*8],0x7
double w_tile(uint64_t L, uint64_t K){
//double w_tile(){
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
 58f:	76 0b                	jbe    59c <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x17c>
            a[i+j] = 7;
 591:	49 01 f3             	add    r11,rsi
 594:	4a c7 04 df 07 00 00 00 	mov    QWORD PTR [rdi+r11*8],0x7
 59c:	48 01 de             	add    rsi,rbx
 59f:	4c 01 c9             	add    rcx,r9
 5a2:	49 39 f0             	cmp    r8,rsi
 5a5:	76 39                	jbe    5e0 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x1c0>
double w_tile(uint64_t L, uint64_t K){
//double w_tile(){
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
 5a7:	48 85 d2             	test   rdx,rdx
 5aa:	74 f0                	je     59c <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x17c>
 5ac:	48 89 c8             	mov    rax,rcx
 5af:	83 e0 1f             	and    eax,0x1f
 5b2:	48 c1 e8 03          	shr    rax,0x3
 5b6:	48 f7 d8             	neg    rax
 5b9:	83 e0 03             	and    eax,0x3
 5bc:	48 39 d0             	cmp    rax,rdx
 5bf:	48 0f 47 c2          	cmova  rax,rdx
 5c3:	48 83 fa 06          	cmp    rdx,0x6
 5c7:	0f 86 e3 fe ff ff    	jbe    4b0 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x90>
 5cd:	48 85 c0             	test   rax,rax
 5d0:	0f 85 dd fe ff ff    	jne    4b3 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x93>
 5d6:	45 31 db             	xor    r11d,r11d
 5d9:	e9 41 ff ff ff       	jmp    51f <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0xff>
 5de:	66 90                	xchg   ax,ax
 5e0:	c5 f8 77             	vzeroupper 
}

double w_tile(uint64_t L, uint64_t K){
//double w_tile(){
    double elapsed = get_time();
    #pragma omp parallel for
 5e3:	5b                   	pop    rbx
 5e4:	41 5a                	pop    r10
 5e6:	41 5c                	pop    r12
 5e8:	41 5d                	pop    r13
 5ea:	41 5e                	pop    r14
 5ec:	41 5f                	pop    r15
 5ee:	5d                   	pop    rbp
 5ef:	c3                   	ret    
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
 5f0:	41 bb 01 00 00 00    	mov    r11d,0x1
 5f6:	e9 1f ff ff ff       	jmp    51a <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0xfa>
 5fb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
 600:	41 bb 05 00 00 00    	mov    r11d,0x5
 606:	e9 0f ff ff ff       	jmp    51a <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0xfa>
 60b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
 610:	41 bb 04 00 00 00    	mov    r11d,0x4
 616:	e9 ff fe ff ff       	jmp    51a <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0xfa>
 61b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
 620:	41 bb 03 00 00 00    	mov    r11d,0x3
 626:	e9 ef fe ff ff       	jmp    51a <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0xfa>
 62b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
 630:	41 bb 02 00 00 00    	mov    r11d,0x2
 636:	e9 df fe ff ff       	jmp    51a <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0xfa>
 63b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000000640 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]>:
    return get_time() - elapsed;
}

double w_dma(data_t** addr, uint64_t* len, uint64_t count) {
    double elapsed = get_time();
    #pragma omp parallel for
 640:	55                   	push   rbp
 641:	48 89 e5             	mov    rbp,rsp
 644:	41 56                	push   r14
 646:	41 55                	push   r13
 648:	41 54                	push   r12
 64a:	41 52                	push   r10
 64c:	53                   	push   rbx
 64d:	48 83 ec 08          	sub    rsp,0x8
    for(uint64_t i = 0; i < count; i++) {
 651:	48 8b 5f 10          	mov    rbx,QWORD PTR [rdi+0x10]
 655:	48 85 db             	test   rbx,rbx
 658:	0f 84 9d 01 00 00    	je     7fb <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x1bb>
 65e:	49 89 fc             	mov    r12,rdi
 661:	e8 00 00 00 00       	call   666 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x26>	662: R_X86_64_PC32	omp_get_num_threads-0x4
 666:	4c 63 e8             	movsxd r13,eax
 669:	e8 00 00 00 00       	call   66e <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x2e>	66a: R_X86_64_PC32	omp_get_thread_num-0x4
 66e:	31 d2                	xor    edx,edx
 670:	4c 63 c0             	movsxd r8,eax
 673:	48 89 d8             	mov    rax,rbx
 676:	49 f7 f5             	div    r13
 679:	49 39 d0             	cmp    r8,rdx
 67c:	73 06                	jae    684 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x44>
 67e:	48 83 c0 01          	add    rax,0x1
 682:	31 d2                	xor    edx,edx
 684:	4c 0f af c0          	imul   r8,rax
 688:	49 01 d0             	add    r8,rdx
 68b:	4e 8d 14 00          	lea    r10,[rax+r8*1]
 68f:	4d 39 d0             	cmp    r8,r10
 692:	0f 83 63 01 00 00    	jae    7fb <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x1bb>
 698:	49 8b 5c 24 08       	mov    rbx,QWORD PTR [r12+0x8]
 69d:	4d 8b 1c 24          	mov    r11,QWORD PTR [r12]
 6a1:	c5 fd 6f 05 00 00 00 00 	vmovdqa ymm0,YMMWORD PTR [rip+0x0]        # 6a9 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x69>	6a5: R_X86_64_PC32	.LC1-0x4
 6a9:	e9 05 01 00 00       	jmp    7b3 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x173>
 6ae:	66 90                	xchg   ax,ax
        const uint64_t c_len = len[i];
        data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
 6b0:	48 89 c8             	mov    rax,rcx
 6b3:	48 83 f8 01          	cmp    rax,0x1
            *c_addr++ = 7;
 6b7:	48 8d 72 08          	lea    rsi,[rdx+0x8]
 6bb:	48 c7 02 07 00 00 00 	mov    QWORD PTR [rdx],0x7
 6c2:	0f 84 48 01 00 00    	je     810 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x1d0>
 6c8:	48 83 f8 02          	cmp    rax,0x2
 6cc:	48 8d 72 10          	lea    rsi,[rdx+0x10]
 6d0:	48 c7 42 08 07 00 00 00 	mov    QWORD PTR [rdx+0x8],0x7
 6d8:	0f 84 72 01 00 00    	je     850 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x210>
 6de:	48 83 f8 03          	cmp    rax,0x3
 6e2:	48 8d 72 18          	lea    rsi,[rdx+0x18]
 6e6:	48 c7 42 10 07 00 00 00 	mov    QWORD PTR [rdx+0x10],0x7
 6ee:	0f 84 4c 01 00 00    	je     840 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x200>
 6f4:	48 83 f8 04          	cmp    rax,0x4
 6f8:	48 8d 72 20          	lea    rsi,[rdx+0x20]
 6fc:	48 c7 42 18 07 00 00 00 	mov    QWORD PTR [rdx+0x18],0x7
 704:	0f 84 26 01 00 00    	je     830 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x1f0>
 70a:	48 83 f8 05          	cmp    rax,0x5
 70e:	48 8d 72 28          	lea    rsi,[rdx+0x28]
 712:	48 c7 42 20 07 00 00 00 	mov    QWORD PTR [rdx+0x20],0x7
 71a:	0f 84 00 01 00 00    	je     820 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x1e0>
 720:	48 8d 72 30          	lea    rsi,[rdx+0x30]
 724:	48 c7 42 28 07 00 00 00 	mov    QWORD PTR [rdx+0x28],0x7
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < count; i++) {
        const uint64_t c_len = len[i];
        data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
 72c:	41 b9 06 00 00 00    	mov    r9d,0x6
 732:	48 39 c8             	cmp    rax,rcx
 735:	74 73                	je     7aa <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x16a>
 737:	49 89 cd             	mov    r13,rcx
 73a:	4c 8d 71 ff          	lea    r14,[rcx-0x1]
 73e:	49 29 c5             	sub    r13,rax
 741:	49 8d 7d fc          	lea    rdi,[r13-0x4]
 745:	49 29 c6             	sub    r14,rax
 748:	48 c1 ef 02          	shr    rdi,0x2
 74c:	48 83 c7 01          	add    rdi,0x1
 750:	49 83 fe 02          	cmp    r14,0x2
 754:	4c 8d 24 bd 00 00 00 00 	lea    r12,[rdi*4+0x0]
 75c:	76 23                	jbe    781 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x141>
 75e:	48 8d 14 c2          	lea    rdx,[rdx+rax*8]
 762:	31 c0                	xor    eax,eax
 764:	48 83 c0 01          	add    rax,0x1
            *c_addr++ = 7;
 768:	c5 fd 7f 02          	vmovdqa YMMWORD PTR [rdx],ymm0
 76c:	48 83 c2 20          	add    rdx,0x20
 770:	48 39 c7             	cmp    rdi,rax
 773:	77 ef                	ja     764 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x124>
 775:	4d 01 e1             	add    r9,r12
 778:	4d 39 e5             	cmp    r13,r12
 77b:	4a 8d 34 e6          	lea    rsi,[rsi+r12*8]
 77f:	74 29                	je     7aa <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x16a>
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < count; i++) {
        const uint64_t c_len = len[i];
        data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
 781:	49 8d 41 01          	lea    rax,[r9+0x1]
            *c_addr++ = 7;
 785:	48 c7 06 07 00 00 00 	mov    QWORD PTR [rsi],0x7
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < count; i++) {
        const uint64_t c_len = len[i];
        data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
 78c:	48 39 c1             	cmp    rcx,rax
 78f:	76 19                	jbe    7aa <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x16a>
 791:	49 83 c1 02          	add    r9,0x2
            *c_addr++ = 7;
 795:	48 c7 46 08 07 00 00 00 	mov    QWORD PTR [rsi+0x8],0x7
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < count; i++) {
        const uint64_t c_len = len[i];
        data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
 79d:	4c 39 c9             	cmp    rcx,r9
 7a0:	76 08                	jbe    7aa <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x16a>
            *c_addr++ = 7;
 7a2:	48 c7 46 10 07 00 00 00 	mov    QWORD PTR [rsi+0x10],0x7
 7aa:	49 83 c0 01          	add    r8,0x1
 7ae:	4d 39 c2             	cmp    r10,r8
 7b1:	74 45                	je     7f8 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x1b8>

double w_dma(data_t** addr, uint64_t* len, uint64_t count) {
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < count; i++) {
        const uint64_t c_len = len[i];
 7b3:	4a 8b 0c c3          	mov    rcx,QWORD PTR [rbx+r8*8]
        data_t* c_addr = addr[i];
 7b7:	4b 8b 14 c3          	mov    rdx,QWORD PTR [r11+r8*8]
        for(uint64_t j = 0; j < c_len; j++) {
 7bb:	48 85 c9             	test   rcx,rcx
 7be:	74 ea                	je     7aa <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x16a>
 7c0:	48 89 d0             	mov    rax,rdx
 7c3:	83 e0 1f             	and    eax,0x1f
 7c6:	48 c1 e8 03          	shr    rax,0x3
 7ca:	48 f7 d8             	neg    rax
 7cd:	83 e0 03             	and    eax,0x3
 7d0:	48 39 c8             	cmp    rax,rcx
 7d3:	48 0f 47 c1          	cmova  rax,rcx
 7d7:	48 83 f9 06          	cmp    rcx,0x6
 7db:	0f 86 cf fe ff ff    	jbe    6b0 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x70>
 7e1:	48 85 c0             	test   rax,rax
 7e4:	0f 85 c9 fe ff ff    	jne    6b3 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x73>
double w_dma(data_t** addr, uint64_t* len, uint64_t count) {
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < count; i++) {
        const uint64_t c_len = len[i];
        data_t* c_addr = addr[i];
 7ea:	48 89 d6             	mov    rsi,rdx
        for(uint64_t j = 0; j < c_len; j++) {
 7ed:	45 31 c9             	xor    r9d,r9d
 7f0:	e9 42 ff ff ff       	jmp    737 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0xf7>
 7f5:	0f 1f 00             	nop    DWORD PTR [rax]
 7f8:	c5 f8 77             	vzeroupper 
    return get_time() - elapsed;
}

double w_dma(data_t** addr, uint64_t* len, uint64_t count) {
    double elapsed = get_time();
    #pragma omp parallel for
 7fb:	48 83 c4 08          	add    rsp,0x8
 7ff:	5b                   	pop    rbx
 800:	41 5a                	pop    r10
 802:	41 5c                	pop    r12
 804:	41 5d                	pop    r13
 806:	41 5e                	pop    r14
 808:	5d                   	pop    rbp
 809:	c3                   	ret    
 80a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    for(uint64_t i = 0; i < count; i++) {
        const uint64_t c_len = len[i];
        data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
 810:	41 b9 01 00 00 00    	mov    r9d,0x1
 816:	e9 17 ff ff ff       	jmp    732 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0xf2>
 81b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
 820:	41 b9 05 00 00 00    	mov    r9d,0x5
 826:	e9 07 ff ff ff       	jmp    732 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0xf2>
 82b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
 830:	41 b9 04 00 00 00    	mov    r9d,0x4
 836:	e9 f7 fe ff ff       	jmp    732 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0xf2>
 83b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
 840:	41 b9 03 00 00 00    	mov    r9d,0x3
 846:	e9 e7 fe ff ff       	jmp    732 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0xf2>
 84b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
 850:	41 b9 02 00 00 00    	mov    r9d,0x2
 856:	e9 d7 fe ff ff       	jmp    732 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0xf2>
 85b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000000860 <w_seq_memset()>:
#include "common.h"

using namespace std;

double w_seq_memset(){
 860:	48 83 ec 18          	sub    rsp,0x18
    volatile data_t* vol_a = a;
    double elapsed = get_time();
 864:	e8 00 00 00 00       	call   869 <w_seq_memset()+0x9>	865: R_X86_64_PC32	get_time()-0x4
 869:	31 c9                	xor    ecx,ecx
 86b:	31 d2                	xor    edx,edx
 86d:	31 f6                	xor    esi,esi
 86f:	bf 00 00 00 00       	mov    edi,0x0	870: R_X86_64_32	.text
 874:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 87a:	e8 00 00 00 00       	call   87f <w_seq_memset()+0x1f>	87b: R_X86_64_PC32	GOMP_parallel-0x4
        uint64_t tid = omp_get_thread_num();
        uint64_t elem_per_thread = HS_ARRAY_ELEM / omp_get_num_threads();
        uint64_t offset = tid * elem_per_thread;        
        memset(a + offset, 7, elem_per_thread * sizeof(data_t));
    }
    return get_time() - elapsed;
 87f:	e8 00 00 00 00       	call   884 <w_seq_memset()+0x24>	880: R_X86_64_PC32	get_time()-0x4
 884:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 88a:	48 83 c4 18          	add    rsp,0x18
 88e:	c3                   	ret    
 88f:	90                   	nop

0000000000000890 <w_seq_fill()>:

double w_seq_fill(){
 890:	48 83 ec 18          	sub    rsp,0x18
    //volatile data_t* vol_a = a;
    double elapsed = get_time();
 894:	e8 00 00 00 00       	call   899 <w_seq_fill()+0x9>	895: R_X86_64_PC32	get_time()-0x4
 899:	31 c9                	xor    ecx,ecx
 89b:	31 d2                	xor    edx,edx
 89d:	31 f6                	xor    esi,esi
 89f:	bf 00 00 00 00       	mov    edi,0x0	8a0: R_X86_64_32	.text+0x50
 8a4:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 8aa:	e8 00 00 00 00       	call   8af <w_seq_fill()+0x1f>	8ab: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        a[i] = 7;
    }
    return get_time() - elapsed;
 8af:	e8 00 00 00 00       	call   8b4 <w_seq_fill()+0x24>	8b0: R_X86_64_PC32	get_time()-0x4
 8b4:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 8ba:	48 83 c4 18          	add    rsp,0x18
 8be:	c3                   	ret    
 8bf:	90                   	nop

00000000000008c0 <w_rand_ind()>:

double w_rand_ind(){
 8c0:	48 83 ec 18          	sub    rsp,0x18
    //volatile data_t * vol_a = a;
    double elapsed = get_time();
 8c4:	e8 00 00 00 00       	call   8c9 <w_rand_ind()+0x9>	8c5: R_X86_64_PC32	get_time()-0x4
 8c9:	31 c9                	xor    ecx,ecx
 8cb:	31 d2                	xor    edx,edx
 8cd:	31 f6                	xor    esi,esi
 8cf:	bf 00 00 00 00       	mov    edi,0x0	8d0: R_X86_64_32	.text+0x1d0
 8d4:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 8da:	e8 00 00 00 00       	call   8df <w_rand_ind()+0x1f>	8db: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        uint64_t idx = ((i * 0xDEADBEEF) ^ 0xC0FFEE0B) % HS_ARRAY_ELEM;
        a[idx] = 7;
    }
    return get_time() - elapsed;
 8df:	e8 00 00 00 00       	call   8e4 <w_rand_ind()+0x24>	8e0: R_X86_64_PC32	get_time()-0x4
 8e4:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 8ea:	48 83 c4 18          	add    rsp,0x18
 8ee:	c3                   	ret    
 8ef:	90                   	nop

00000000000008f0 <w_stride_2()>:

double w_stride_2(){
 8f0:	48 83 ec 18          	sub    rsp,0x18
    double elapsed = get_time();
 8f4:	e8 00 00 00 00       	call   8f9 <w_stride_2()+0x9>	8f5: R_X86_64_PC32	get_time()-0x4
 8f9:	31 c9                	xor    ecx,ecx
 8fb:	31 d2                	xor    edx,edx
 8fd:	31 f6                	xor    esi,esi
 8ff:	bf 00 00 00 00       	mov    edi,0x0	900: R_X86_64_32	.text+0x240
 904:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 90a:	e8 00 00 00 00       	call   90f <w_stride_2()+0x1f>	90b: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 2) {
        a[i] = 7;
    }
    return get_time() - elapsed;
 90f:	e8 00 00 00 00       	call   914 <w_stride_2()+0x24>	910: R_X86_64_PC32	get_time()-0x4
 914:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 91a:	48 83 c4 18          	add    rsp,0x18
 91e:	c3                   	ret    
 91f:	90                   	nop

0000000000000920 <w_stride_4()>:

double w_stride_4(){
 920:	48 83 ec 18          	sub    rsp,0x18
    double elapsed = get_time();
 924:	e8 00 00 00 00       	call   929 <w_stride_4()+0x9>	925: R_X86_64_PC32	get_time()-0x4
 929:	31 c9                	xor    ecx,ecx
 92b:	31 d2                	xor    edx,edx
 92d:	31 f6                	xor    esi,esi
 92f:	bf 00 00 00 00       	mov    edi,0x0	930: R_X86_64_32	.text+0x2a0
 934:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 93a:	e8 00 00 00 00       	call   93f <w_stride_4()+0x1f>	93b: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 4) {
        a[i] = 7;
    }
    return get_time() - elapsed;
 93f:	e8 00 00 00 00       	call   944 <w_stride_4()+0x24>	940: R_X86_64_PC32	get_time()-0x4
 944:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 94a:	48 83 c4 18          	add    rsp,0x18
 94e:	c3                   	ret    
 94f:	90                   	nop

0000000000000950 <w_stride_8()>:

double w_stride_8(){
 950:	48 83 ec 18          	sub    rsp,0x18
    double elapsed = get_time();
 954:	e8 00 00 00 00       	call   959 <w_stride_8()+0x9>	955: R_X86_64_PC32	get_time()-0x4
 959:	31 c9                	xor    ecx,ecx
 95b:	31 d2                	xor    edx,edx
 95d:	31 f6                	xor    esi,esi
 95f:	bf 00 00 00 00       	mov    edi,0x0	960: R_X86_64_32	.text+0x300
 964:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 96a:	e8 00 00 00 00       	call   96f <w_stride_8()+0x1f>	96b: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 8) {
        a[i] = 7;
    }
    return get_time() - elapsed;
 96f:	e8 00 00 00 00       	call   974 <w_stride_8()+0x24>	970: R_X86_64_PC32	get_time()-0x4
 974:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 97a:	48 83 c4 18          	add    rsp,0x18
 97e:	c3                   	ret    
 97f:	90                   	nop

0000000000000980 <w_stride_16()>:

double w_stride_16(){
 980:	48 83 ec 18          	sub    rsp,0x18
    double elapsed = get_time();
 984:	e8 00 00 00 00       	call   989 <w_stride_16()+0x9>	985: R_X86_64_PC32	get_time()-0x4
 989:	31 c9                	xor    ecx,ecx
 98b:	31 d2                	xor    edx,edx
 98d:	31 f6                	xor    esi,esi
 98f:	bf 00 00 00 00       	mov    edi,0x0	990: R_X86_64_32	.text+0x360
 994:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 99a:	e8 00 00 00 00       	call   99f <w_stride_16()+0x1f>	99b: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 16) {
        a[i] = 7;
    }
    return get_time() - elapsed;
 99f:	e8 00 00 00 00       	call   9a4 <w_stride_16()+0x24>	9a0: R_X86_64_PC32	get_time()-0x4
 9a4:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 9aa:	48 83 c4 18          	add    rsp,0x18
 9ae:	c3                   	ret    
 9af:	90                   	nop

00000000000009b0 <w_stride_32()>:

double w_stride_32(){
 9b0:	48 83 ec 18          	sub    rsp,0x18
    double elapsed = get_time();
 9b4:	e8 00 00 00 00       	call   9b9 <w_stride_32()+0x9>	9b5: R_X86_64_PC32	get_time()-0x4
 9b9:	31 c9                	xor    ecx,ecx
 9bb:	31 d2                	xor    edx,edx
 9bd:	31 f6                	xor    esi,esi
 9bf:	bf 00 00 00 00       	mov    edi,0x0	9c0: R_X86_64_32	.text+0x3c0
 9c4:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 9ca:	e8 00 00 00 00       	call   9cf <w_stride_32()+0x1f>	9cb: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 32) {
        a[i] = 7;
    }
    return get_time() - elapsed;
 9cf:	e8 00 00 00 00       	call   9d4 <w_stride_32()+0x24>	9d0: R_X86_64_PC32	get_time()-0x4
 9d4:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 9da:	48 83 c4 18          	add    rsp,0x18
 9de:	c3                   	ret    
 9df:	90                   	nop

00000000000009e0 <w_tile(unsigned long, unsigned long)>:

double w_tile(uint64_t L, uint64_t K){
 9e0:	55                   	push   rbp
 9e1:	53                   	push   rbx
 9e2:	48 89 fd             	mov    rbp,rdi
 9e5:	48 89 f3             	mov    rbx,rsi
 9e8:	48 83 ec 38          	sub    rsp,0x38
 9ec:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 9f5:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
 9fa:	31 c0                	xor    eax,eax
//double w_tile(){
    double elapsed = get_time();
 9fc:	e8 00 00 00 00       	call   a01 <w_tile(unsigned long, unsigned long)+0x21>	9fd: R_X86_64_PC32	get_time()-0x4
 a01:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
 a06:	31 c9                	xor    ecx,ecx
 a08:	31 d2                	xor    edx,edx
 a0a:	bf 00 00 00 00       	mov    edi,0x0	a0b: R_X86_64_32	.text+0x420
 a0f:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
    #pragma omp parallel for
 a15:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
 a1a:	48 89 5c 24 18       	mov    QWORD PTR [rsp+0x18],rbx
 a1f:	e8 00 00 00 00       	call   a24 <w_tile(unsigned long, unsigned long)+0x44>	a20: R_X86_64_PC32	GOMP_parallel-0x4
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
            a[i+j] = 7;
        }
    }
    return get_time() - elapsed;
 a24:	e8 00 00 00 00       	call   a29 <w_tile(unsigned long, unsigned long)+0x49>	a25: R_X86_64_PC32	get_time()-0x4
}
 a29:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
 a2e:	64 48 33 04 25 28 00 00 00 	xor    rax,QWORD PTR fs:0x28
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
            a[i+j] = 7;
        }
    }
    return get_time() - elapsed;
 a37:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 a3d:	75 07                	jne    a46 <w_tile(unsigned long, unsigned long)+0x66>
 a3f:	48 83 c4 38          	add    rsp,0x38
 a43:	5b                   	pop    rbx
 a44:	5d                   	pop    rbp
 a45:	c3                   	ret    
 a46:	e8 00 00 00 00       	call   a4b <w_tile(unsigned long, unsigned long)+0x6b>	a47: R_X86_64_PC32	__stack_chk_fail-0x4
 a4b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000000a50 <w_dma(unsigned long**, unsigned long*, unsigned long)>:

double w_dma(data_t** addr, uint64_t* len, uint64_t count) {
 a50:	41 54                	push   r12
 a52:	55                   	push   rbp
 a53:	49 89 fc             	mov    r12,rdi
 a56:	53                   	push   rbx
 a57:	48 89 f5             	mov    rbp,rsi
 a5a:	48 89 d3             	mov    rbx,rdx
 a5d:	48 83 ec 30          	sub    rsp,0x30
 a61:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 a6a:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
 a6f:	31 c0                	xor    eax,eax
    double elapsed = get_time();
 a71:	e8 00 00 00 00       	call   a76 <w_dma(unsigned long**, unsigned long*, unsigned long)+0x26>	a72: R_X86_64_PC32	get_time()-0x4
 a76:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
 a7b:	31 c9                	xor    ecx,ecx
 a7d:	31 d2                	xor    edx,edx
 a7f:	bf 00 00 00 00       	mov    edi,0x0	a80: R_X86_64_32	.text+0x640
 a84:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
    #pragma omp parallel for
 a8a:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
 a8f:	48 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],rbp
 a94:	48 89 5c 24 20       	mov    QWORD PTR [rsp+0x20],rbx
 a99:	e8 00 00 00 00       	call   a9e <w_dma(unsigned long**, unsigned long*, unsigned long)+0x4e>	a9a: R_X86_64_PC32	GOMP_parallel-0x4
        data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
            *c_addr++ = 7;
        }
    }
    return get_time() - elapsed;
 a9e:	e8 00 00 00 00       	call   aa3 <w_dma(unsigned long**, unsigned long*, unsigned long)+0x53>	a9f: R_X86_64_PC32	get_time()-0x4
}
 aa3:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
 aa8:	64 48 33 04 25 28 00 00 00 	xor    rax,QWORD PTR fs:0x28
        data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
            *c_addr++ = 7;
        }
    }
    return get_time() - elapsed;
 ab1:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 ab7:	75 09                	jne    ac2 <w_dma(unsigned long**, unsigned long*, unsigned long)+0x72>
 ab9:	48 83 c4 30          	add    rsp,0x30
 abd:	5b                   	pop    rbx
 abe:	5d                   	pop    rbp
 abf:	41 5c                	pop    r12
 ac1:	c3                   	ret    
 ac2:	e8 00 00 00 00       	call   ac7 <w_dma(unsigned long**, unsigned long*, unsigned long)+0x77>	ac3: R_X86_64_PC32	__stack_chk_fail-0x4
