
write_kernels.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <w_seq_memset() [clone ._omp_fn.0]>:
using namespace std;

double w_seq_memset(){
    volatile data_t* vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel
   0:	53                   	push   rbx
    {
        uint64_t tid = omp_get_thread_num();
   1:	e8 00 00 00 00       	call   6 <w_seq_memset() [clone ._omp_fn.0]+0x6>	2: R_X86_64_PC32	omp_get_thread_num-0x4
   6:	89 c3                	mov    ebx,eax
        uint64_t elem_per_thread = HS_ARRAY_ELEM / omp_get_num_threads();
   8:	e8 00 00 00 00       	call   d <w_seq_memset() [clone ._omp_fn.0]+0xd>	9: R_X86_64_PC32	omp_get_num_threads-0x4
   d:	31 d2                	xor    edx,edx
   f:	48 63 c8             	movsxd rcx,eax
  12:	b8 00 00 00 04       	mov    eax,0x4000000
  17:	48 f7 f1             	div    rcx
    {
      __warn_memset_zero_len ();
      return __dest;
    }
#endif
  return __builtin___memset_chk (__dest, __ch, __len, __bos0 (__dest));
  1a:	48 63 fb             	movsxd rdi,ebx
  1d:	be 07 00 00 00       	mov    esi,0x7
  22:	48 c1 e7 03          	shl    rdi,0x3
using namespace std;

double w_seq_memset(){
    volatile data_t* vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel
  26:	5b                   	pop    rbx
  27:	48 8d 14 c5 00 00 00 00 	lea    rdx,[rax*8+0x0]
  2f:	48 0f af c7          	imul   rax,rdi
  33:	48 03 05 00 00 00 00 	add    rax,QWORD PTR [rip+0x0]        # 3a <w_seq_memset() [clone ._omp_fn.0]+0x3a>	36: R_X86_64_PC32	a-0x4
  3a:	48 89 c7             	mov    rdi,rax
  3d:	e9 00 00 00 00       	jmp    42 <w_seq_memset() [clone ._omp_fn.0]+0x42>	3e: R_X86_64_PC32	memset-0x4
  42:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
  46:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

0000000000000050 <w_seq_fill() [clone ._omp_fn.1]>:

double w_seq_fill(){
    //volatile data_t* vol_a = a;
    double elapsed = get_time();
    //#pragma omp parallel for
    #pragma omp parallel for simd aligned(a: 32)
  50:	55                   	push   rbp
  51:	48 89 e5             	mov    rbp,rsp
  54:	41 52                	push   r10
  56:	53                   	push   rbx
  57:	e8 00 00 00 00       	call   5c <w_seq_fill() [clone ._omp_fn.1]+0xc>	58: R_X86_64_PC32	omp_get_num_threads-0x4
  5c:	48 63 d8             	movsxd rbx,eax
  5f:	e8 00 00 00 00       	call   64 <w_seq_fill() [clone ._omp_fn.1]+0x14>	60: R_X86_64_PC32	omp_get_thread_num-0x4
  64:	31 d2                	xor    edx,edx
  66:	48 63 c8             	movsxd rcx,eax
  69:	b8 00 00 00 04       	mov    eax,0x4000000
  6e:	48 f7 f3             	div    rbx
  71:	48 39 d1             	cmp    rcx,rdx
  74:	0f 83 2e 01 00 00    	jae    1a8 <w_seq_fill() [clone ._omp_fn.1]+0x158>
  7a:	48 83 c0 01          	add    rax,0x1
  7e:	48 89 ca             	mov    rdx,rcx
  81:	48 0f af d0          	imul   rdx,rax
  85:	48 01 d0             	add    rax,rdx
  88:	48 39 c2             	cmp    rdx,rax
  8b:	0f 83 0b 01 00 00    	jae    19c <w_seq_fill() [clone ._omp_fn.1]+0x14c>
  91:	4c 8b 05 00 00 00 00 	mov    r8,QWORD PTR [rip+0x0]        # 98 <w_seq_fill() [clone ._omp_fn.1]+0x48>	94: R_X86_64_PC32	a-0x4
  98:	4c 8d 52 01          	lea    r10,[rdx+0x1]
  9c:	48 89 c1             	mov    rcx,rax
  9f:	48 29 d1             	sub    rcx,rdx
  a2:	be 01 00 00 00       	mov    esi,0x1
  a7:	49 39 c2             	cmp    r10,rax
  aa:	49 8d 3c d0          	lea    rdi,[r8+rdx*8]
  ae:	48 0f 46 f1          	cmovbe rsi,rcx
  b2:	48 89 f9             	mov    rcx,rdi
  b5:	83 e1 1f             	and    ecx,0x1f
  b8:	48 c1 e9 03          	shr    rcx,0x3
  bc:	48 f7 d9             	neg    rcx
  bf:	83 e1 03             	and    ecx,0x3
  c2:	48 39 f1             	cmp    rcx,rsi
  c5:	48 0f 47 ce          	cmova  rcx,rsi
  c9:	48 83 fe 03          	cmp    rsi,0x3
  cd:	48 0f 46 ce          	cmovbe rcx,rsi
  d1:	48 85 c9             	test   rcx,rcx
  d4:	0f 84 e6 00 00 00    	je     1c0 <w_seq_fill() [clone ._omp_fn.1]+0x170>
  da:	48 83 f9 01          	cmp    rcx,0x1
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        a[i] = 7;
  de:	48 c7 07 07 00 00 00 	mov    QWORD PTR [rdi],0x7
  e5:	4c 89 d7             	mov    rdi,r10
  e8:	74 1e                	je     108 <w_seq_fill() [clone ._omp_fn.1]+0xb8>
  ea:	48 83 f9 03          	cmp    rcx,0x3
  ee:	4b c7 04 d0 07 00 00 00 	mov    QWORD PTR [r8+r10*8],0x7
  f6:	48 8d 7a 02          	lea    rdi,[rdx+0x2]
  fa:	75 0c                	jne    108 <w_seq_fill() [clone ._omp_fn.1]+0xb8>
  fc:	49 c7 04 f8 07 00 00 00 	mov    QWORD PTR [r8+rdi*8],0x7
 104:	48 8d 7a 03          	lea    rdi,[rdx+0x3]
 108:	48 39 ce             	cmp    rsi,rcx
 10b:	0f 84 8b 00 00 00    	je     19c <w_seq_fill() [clone ._omp_fn.1]+0x14c>
 111:	48 29 ce             	sub    rsi,rcx
 114:	4c 8d 48 ff          	lea    r9,[rax-0x1]
 118:	4c 8d 5e fc          	lea    r11,[rsi-0x4]
 11c:	49 29 d1             	sub    r9,rdx
 11f:	49 c1 eb 02          	shr    r11,0x2
 123:	49 83 c3 01          	add    r11,0x1
 127:	49 39 c2             	cmp    r10,rax
 12a:	41 ba 00 00 00 00    	mov    r10d,0x0
 130:	4d 0f 47 ca          	cmova  r9,r10
 134:	4a 8d 1c 9d 00 00 00 00 	lea    rbx,[r11*4+0x0]
 13c:	49 29 c9             	sub    r9,rcx
 13f:	49 83 f9 02          	cmp    r9,0x2
 143:	76 2d                	jbe    172 <w_seq_fill() [clone ._omp_fn.1]+0x122>
 145:	48 01 ca             	add    rdx,rcx
 148:	c5 fd 6f 05 00 00 00 00 	vmovdqa ymm0,YMMWORD PTR [rip+0x0]        # 150 <w_seq_fill() [clone ._omp_fn.1]+0x100>	14c: R_X86_64_PC32	.LC1-0x4
 150:	49 8d 0c d0          	lea    rcx,[r8+rdx*8]
 154:	31 d2                	xor    edx,edx
 156:	48 83 c2 01          	add    rdx,0x1
 15a:	c5 fd 7f 01          	vmovdqa YMMWORD PTR [rcx],ymm0
 15e:	48 83 c1 20          	add    rcx,0x20
 162:	49 39 d3             	cmp    r11,rdx
 165:	77 ef                	ja     156 <w_seq_fill() [clone ._omp_fn.1]+0x106>
 167:	48 01 df             	add    rdi,rbx
 16a:	48 39 de             	cmp    rsi,rbx
 16d:	74 61                	je     1d0 <w_seq_fill() [clone ._omp_fn.1]+0x180>
 16f:	c5 f8 77             	vzeroupper 
 172:	48 8d 57 01          	lea    rdx,[rdi+0x1]
 176:	49 c7 04 f8 07 00 00 00 	mov    QWORD PTR [r8+rdi*8],0x7
 17e:	48 39 c2             	cmp    rdx,rax
 181:	73 19                	jae    19c <w_seq_fill() [clone ._omp_fn.1]+0x14c>
 183:	48 83 c7 02          	add    rdi,0x2
 187:	49 c7 04 d0 07 00 00 00 	mov    QWORD PTR [r8+rdx*8],0x7
 18f:	48 39 f8             	cmp    rax,rdi
 192:	76 08                	jbe    19c <w_seq_fill() [clone ._omp_fn.1]+0x14c>
 194:	49 c7 04 f8 07 00 00 00 	mov    QWORD PTR [r8+rdi*8],0x7

double w_seq_fill(){
    //volatile data_t* vol_a = a;
    double elapsed = get_time();
    //#pragma omp parallel for
    #pragma omp parallel for simd aligned(a: 32)
 19c:	5b                   	pop    rbx
 19d:	41 5a                	pop    r10
 19f:	5d                   	pop    rbp
 1a0:	c3                   	ret    
 1a1:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
 1a8:	48 0f af c8          	imul   rcx,rax
 1ac:	48 01 ca             	add    rdx,rcx
 1af:	48 01 d0             	add    rax,rdx
 1b2:	48 39 c2             	cmp    rdx,rax
 1b5:	0f 82 d6 fe ff ff    	jb     91 <w_seq_fill() [clone ._omp_fn.1]+0x41>
 1bb:	eb df                	jmp    19c <w_seq_fill() [clone ._omp_fn.1]+0x14c>
 1bd:	0f 1f 00             	nop    DWORD PTR [rax]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        a[i] = 7;
 1c0:	48 89 d7             	mov    rdi,rdx
 1c3:	e9 49 ff ff ff       	jmp    111 <w_seq_fill() [clone ._omp_fn.1]+0xc1>
 1c8:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
 1d0:	c5 f8 77             	vzeroupper 
 1d3:	eb c7                	jmp    19c <w_seq_fill() [clone ._omp_fn.1]+0x14c>
 1d5:	90                   	nop
 1d6:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

00000000000001e0 <w_rand_ind() [clone ._omp_fn.2]>:
}

double w_rand_ind(){
    //volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 1e0:	53                   	push   rbx
 1e1:	e8 00 00 00 00       	call   1e6 <w_rand_ind() [clone ._omp_fn.2]+0x6>	1e2: R_X86_64_PC32	omp_get_num_threads-0x4
 1e6:	48 63 d8             	movsxd rbx,eax
 1e9:	e8 00 00 00 00       	call   1ee <w_rand_ind() [clone ._omp_fn.2]+0xe>	1ea: R_X86_64_PC32	omp_get_thread_num-0x4
 1ee:	31 d2                	xor    edx,edx
 1f0:	48 63 c8             	movsxd rcx,eax
 1f3:	b8 00 00 00 04       	mov    eax,0x4000000
 1f8:	48 f7 f3             	div    rbx
 1fb:	48 39 d1             	cmp    rcx,rdx
 1fe:	73 06                	jae    206 <w_rand_ind() [clone ._omp_fn.2]+0x26>
 200:	48 83 c0 01          	add    rax,0x1
 204:	31 d2                	xor    edx,edx
 206:	48 0f af c8          	imul   rcx,rax
 20a:	48 01 ca             	add    rdx,rcx
 20d:	48 01 d0             	add    rax,rdx
 210:	48 39 c2             	cmp    rdx,rax
 213:	73 37                	jae    24c <w_rand_ind() [clone ._omp_fn.2]+0x6c>
 215:	be ef be ad de       	mov    esi,0xdeadbeef
 21a:	4c 8b 05 00 00 00 00 	mov    r8,QWORD PTR [rip+0x0]        # 221 <w_rand_ind() [clone ._omp_fn.2]+0x41>	21d: R_X86_64_PC32	a-0x4
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        uint64_t idx = ((i * 0xDEADBEEF) ^ 0xC0FFEE0B) % HS_ARRAY_ELEM;
        a[idx] = 7;
 221:	bf 0b ee ff c0       	mov    edi,0xc0ffee0b
 226:	48 0f af d6          	imul   rdx,rsi
 22a:	48 0f af c6          	imul   rax,rsi
 22e:	66 90                	xchg   ax,ax
 230:	48 89 d1             	mov    rcx,rdx
 233:	48 01 f2             	add    rdx,rsi
 236:	48 31 f9             	xor    rcx,rdi
 239:	81 e1 ff ff ff 03    	and    ecx,0x3ffffff
 23f:	48 39 d0             	cmp    rax,rdx
 242:	49 c7 04 c8 07 00 00 00 	mov    QWORD PTR [r8+rcx*8],0x7
 24a:	75 e4                	jne    230 <w_rand_ind() [clone ._omp_fn.2]+0x50>
}

double w_rand_ind(){
    //volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 24c:	5b                   	pop    rbx
 24d:	c3                   	ret    
 24e:	66 90                	xchg   ax,ax

0000000000000250 <w_stride_2() [clone ._omp_fn.3]>:
    return get_time() - elapsed;
}

double w_stride_2(){
    double elapsed = get_time();
    #pragma omp parallel for
 250:	53                   	push   rbx
 251:	e8 00 00 00 00       	call   256 <w_stride_2() [clone ._omp_fn.3]+0x6>	252: R_X86_64_PC32	omp_get_num_threads-0x4
 256:	48 63 d8             	movsxd rbx,eax
 259:	e8 00 00 00 00       	call   25e <w_stride_2() [clone ._omp_fn.3]+0xe>	25a: R_X86_64_PC32	omp_get_thread_num-0x4
 25e:	31 d2                	xor    edx,edx
 260:	48 63 c8             	movsxd rcx,eax
 263:	b8 00 00 00 02       	mov    eax,0x2000000
 268:	48 f7 f3             	div    rbx
 26b:	48 39 d1             	cmp    rcx,rdx
 26e:	73 06                	jae    276 <w_stride_2() [clone ._omp_fn.3]+0x26>
 270:	48 83 c0 01          	add    rax,0x1
 274:	31 d2                	xor    edx,edx
 276:	48 0f af c8          	imul   rcx,rax
 27a:	48 01 ca             	add    rdx,rcx
 27d:	48 01 d0             	add    rax,rdx
 280:	48 39 c2             	cmp    rdx,rax
 283:	73 24                	jae    2a9 <w_stride_2() [clone ._omp_fn.3]+0x59>
 285:	48 8b 0d 00 00 00 00 	mov    rcx,QWORD PTR [rip+0x0]        # 28c <w_stride_2() [clone ._omp_fn.3]+0x3c>	288: R_X86_64_PC32	a-0x4
 28c:	48 01 d2             	add    rdx,rdx
 28f:	48 01 c0             	add    rax,rax
 292:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 2) {
        a[i] = 7;
 298:	48 c7 04 d1 07 00 00 00 	mov    QWORD PTR [rcx+rdx*8],0x7
 2a0:	48 83 c2 02          	add    rdx,0x2
 2a4:	48 39 d0             	cmp    rax,rdx
 2a7:	77 ef                	ja     298 <w_stride_2() [clone ._omp_fn.3]+0x48>
    return get_time() - elapsed;
}

double w_stride_2(){
    double elapsed = get_time();
    #pragma omp parallel for
 2a9:	5b                   	pop    rbx
 2aa:	c3                   	ret    
 2ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000000002b0 <w_stride_4() [clone ._omp_fn.4]>:
    return get_time() - elapsed;
}

double w_stride_4(){
    double elapsed = get_time();
    #pragma omp parallel for
 2b0:	53                   	push   rbx
 2b1:	e8 00 00 00 00       	call   2b6 <w_stride_4() [clone ._omp_fn.4]+0x6>	2b2: R_X86_64_PC32	omp_get_num_threads-0x4
 2b6:	48 63 d8             	movsxd rbx,eax
 2b9:	e8 00 00 00 00       	call   2be <w_stride_4() [clone ._omp_fn.4]+0xe>	2ba: R_X86_64_PC32	omp_get_thread_num-0x4
 2be:	31 d2                	xor    edx,edx
 2c0:	48 63 c8             	movsxd rcx,eax
 2c3:	b8 00 00 00 01       	mov    eax,0x1000000
 2c8:	48 f7 f3             	div    rbx
 2cb:	48 39 d1             	cmp    rcx,rdx
 2ce:	73 06                	jae    2d6 <w_stride_4() [clone ._omp_fn.4]+0x26>
 2d0:	48 83 c0 01          	add    rax,0x1
 2d4:	31 d2                	xor    edx,edx
 2d6:	48 0f af c8          	imul   rcx,rax
 2da:	48 01 ca             	add    rdx,rcx
 2dd:	48 01 d0             	add    rax,rdx
 2e0:	48 39 c2             	cmp    rdx,rax
 2e3:	73 24                	jae    309 <w_stride_4() [clone ._omp_fn.4]+0x59>
 2e5:	48 8b 0d 00 00 00 00 	mov    rcx,QWORD PTR [rip+0x0]        # 2ec <w_stride_4() [clone ._omp_fn.4]+0x3c>	2e8: R_X86_64_PC32	a-0x4
 2ec:	48 c1 e2 02          	shl    rdx,0x2
 2f0:	48 c1 e0 02          	shl    rax,0x2
 2f4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 4) {
        a[i] = 7;
 2f8:	48 c7 04 d1 07 00 00 00 	mov    QWORD PTR [rcx+rdx*8],0x7
 300:	48 83 c2 04          	add    rdx,0x4
 304:	48 39 d0             	cmp    rax,rdx
 307:	77 ef                	ja     2f8 <w_stride_4() [clone ._omp_fn.4]+0x48>
    return get_time() - elapsed;
}

double w_stride_4(){
    double elapsed = get_time();
    #pragma omp parallel for
 309:	5b                   	pop    rbx
 30a:	c3                   	ret    
 30b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000000310 <w_stride_8() [clone ._omp_fn.5]>:
    return get_time() - elapsed;
}

double w_stride_8(){
    double elapsed = get_time();
    #pragma omp parallel for
 310:	53                   	push   rbx
 311:	e8 00 00 00 00       	call   316 <w_stride_8() [clone ._omp_fn.5]+0x6>	312: R_X86_64_PC32	omp_get_num_threads-0x4
 316:	48 63 d8             	movsxd rbx,eax
 319:	e8 00 00 00 00       	call   31e <w_stride_8() [clone ._omp_fn.5]+0xe>	31a: R_X86_64_PC32	omp_get_thread_num-0x4
 31e:	31 d2                	xor    edx,edx
 320:	48 63 c8             	movsxd rcx,eax
 323:	b8 00 00 80 00       	mov    eax,0x800000
 328:	48 f7 f3             	div    rbx
 32b:	48 39 d1             	cmp    rcx,rdx
 32e:	73 06                	jae    336 <w_stride_8() [clone ._omp_fn.5]+0x26>
 330:	48 83 c0 01          	add    rax,0x1
 334:	31 d2                	xor    edx,edx
 336:	48 0f af c8          	imul   rcx,rax
 33a:	48 01 ca             	add    rdx,rcx
 33d:	48 01 d0             	add    rax,rdx
 340:	48 39 c2             	cmp    rdx,rax
 343:	73 24                	jae    369 <w_stride_8() [clone ._omp_fn.5]+0x59>
 345:	48 8b 0d 00 00 00 00 	mov    rcx,QWORD PTR [rip+0x0]        # 34c <w_stride_8() [clone ._omp_fn.5]+0x3c>	348: R_X86_64_PC32	a-0x4
 34c:	48 c1 e2 03          	shl    rdx,0x3
 350:	48 c1 e0 03          	shl    rax,0x3
 354:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 8) {
        a[i] = 7;
 358:	48 c7 04 d1 07 00 00 00 	mov    QWORD PTR [rcx+rdx*8],0x7
 360:	48 83 c2 08          	add    rdx,0x8
 364:	48 39 d0             	cmp    rax,rdx
 367:	77 ef                	ja     358 <w_stride_8() [clone ._omp_fn.5]+0x48>
    return get_time() - elapsed;
}

double w_stride_8(){
    double elapsed = get_time();
    #pragma omp parallel for
 369:	5b                   	pop    rbx
 36a:	c3                   	ret    
 36b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000000370 <w_stride_16() [clone ._omp_fn.6]>:
    return get_time() - elapsed;
}

double w_stride_16(){
    double elapsed = get_time();
    #pragma omp parallel for
 370:	53                   	push   rbx
 371:	e8 00 00 00 00       	call   376 <w_stride_16() [clone ._omp_fn.6]+0x6>	372: R_X86_64_PC32	omp_get_num_threads-0x4
 376:	48 63 d8             	movsxd rbx,eax
 379:	e8 00 00 00 00       	call   37e <w_stride_16() [clone ._omp_fn.6]+0xe>	37a: R_X86_64_PC32	omp_get_thread_num-0x4
 37e:	31 d2                	xor    edx,edx
 380:	48 63 c8             	movsxd rcx,eax
 383:	b8 00 00 40 00       	mov    eax,0x400000
 388:	48 f7 f3             	div    rbx
 38b:	48 39 d1             	cmp    rcx,rdx
 38e:	73 06                	jae    396 <w_stride_16() [clone ._omp_fn.6]+0x26>
 390:	48 83 c0 01          	add    rax,0x1
 394:	31 d2                	xor    edx,edx
 396:	48 0f af c8          	imul   rcx,rax
 39a:	48 01 ca             	add    rdx,rcx
 39d:	48 01 d0             	add    rax,rdx
 3a0:	48 39 c2             	cmp    rdx,rax
 3a3:	73 24                	jae    3c9 <w_stride_16() [clone ._omp_fn.6]+0x59>
 3a5:	48 8b 0d 00 00 00 00 	mov    rcx,QWORD PTR [rip+0x0]        # 3ac <w_stride_16() [clone ._omp_fn.6]+0x3c>	3a8: R_X86_64_PC32	a-0x4
 3ac:	48 c1 e2 04          	shl    rdx,0x4
 3b0:	48 c1 e0 04          	shl    rax,0x4
 3b4:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 16) {
        a[i] = 7;
 3b8:	48 c7 04 d1 07 00 00 00 	mov    QWORD PTR [rcx+rdx*8],0x7
 3c0:	48 83 c2 10          	add    rdx,0x10
 3c4:	48 39 d0             	cmp    rax,rdx
 3c7:	77 ef                	ja     3b8 <w_stride_16() [clone ._omp_fn.6]+0x48>
    return get_time() - elapsed;
}

double w_stride_16(){
    double elapsed = get_time();
    #pragma omp parallel for
 3c9:	5b                   	pop    rbx
 3ca:	c3                   	ret    
 3cb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000000003d0 <w_stride_32() [clone ._omp_fn.7]>:
    return get_time() - elapsed;
}

double w_stride_32(){
    double elapsed = get_time();
    #pragma omp parallel for
 3d0:	53                   	push   rbx
 3d1:	e8 00 00 00 00       	call   3d6 <w_stride_32() [clone ._omp_fn.7]+0x6>	3d2: R_X86_64_PC32	omp_get_num_threads-0x4
 3d6:	48 63 d8             	movsxd rbx,eax
 3d9:	e8 00 00 00 00       	call   3de <w_stride_32() [clone ._omp_fn.7]+0xe>	3da: R_X86_64_PC32	omp_get_thread_num-0x4
 3de:	31 d2                	xor    edx,edx
 3e0:	48 63 c8             	movsxd rcx,eax
 3e3:	b8 00 00 20 00       	mov    eax,0x200000
 3e8:	48 f7 f3             	div    rbx
 3eb:	48 39 d1             	cmp    rcx,rdx
 3ee:	73 06                	jae    3f6 <w_stride_32() [clone ._omp_fn.7]+0x26>
 3f0:	48 83 c0 01          	add    rax,0x1
 3f4:	31 d2                	xor    edx,edx
 3f6:	48 0f af c8          	imul   rcx,rax
 3fa:	48 01 ca             	add    rdx,rcx
 3fd:	48 01 d0             	add    rax,rdx
 400:	48 39 c2             	cmp    rdx,rax
 403:	73 24                	jae    429 <w_stride_32() [clone ._omp_fn.7]+0x59>
 405:	48 8b 0d 00 00 00 00 	mov    rcx,QWORD PTR [rip+0x0]        # 40c <w_stride_32() [clone ._omp_fn.7]+0x3c>	408: R_X86_64_PC32	a-0x4
 40c:	48 c1 e2 05          	shl    rdx,0x5
 410:	48 c1 e0 05          	shl    rax,0x5
 414:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 32) {
        a[i] = 7;
 418:	48 c7 04 d1 07 00 00 00 	mov    QWORD PTR [rcx+rdx*8],0x7
 420:	48 83 c2 20          	add    rdx,0x20
 424:	48 39 d0             	cmp    rax,rdx
 427:	77 ef                	ja     418 <w_stride_32() [clone ._omp_fn.7]+0x48>
    return get_time() - elapsed;
}

double w_stride_32(){
    double elapsed = get_time();
    #pragma omp parallel for
 429:	5b                   	pop    rbx
 42a:	c3                   	ret    
 42b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000000430 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]>:
}

double w_tile(uint64_t L, uint64_t K){
//double w_tile(){
    double elapsed = get_time();
    #pragma omp parallel for
 430:	55                   	push   rbp
 431:	48 89 e5             	mov    rbp,rsp
 434:	41 57                	push   r15
 436:	41 56                	push   r14
 438:	41 55                	push   r13
 43a:	41 54                	push   r12
 43c:	49 89 fd             	mov    r13,rdi
 43f:	41 52                	push   r10
 441:	53                   	push   rbx
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
 442:	48 8b 5f 08          	mov    rbx,QWORD PTR [rdi+0x8]
 446:	e8 00 00 00 00       	call   44b <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x1b>	447: R_X86_64_PC32	omp_get_num_threads-0x4
 44b:	4c 63 e0             	movsxd r12,eax
 44e:	e8 00 00 00 00       	call   453 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x23>	44f: R_X86_64_PC32	omp_get_thread_num-0x4
 453:	48 63 f0             	movsxd rsi,eax
 456:	48 8d 83 ff ff ff 03 	lea    rax,[rbx+0x3ffffff]
 45d:	31 d2                	xor    edx,edx
 45f:	48 f7 f3             	div    rbx
 462:	31 d2                	xor    edx,edx
 464:	49 f7 f4             	div    r12
 467:	48 39 d6             	cmp    rsi,rdx
 46a:	73 06                	jae    472 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x42>
 46c:	48 83 c0 01          	add    rax,0x1
 470:	31 d2                	xor    edx,edx
 472:	48 0f af f0          	imul   rsi,rax
 476:	48 01 d6             	add    rsi,rdx
 479:	4c 8d 04 30          	lea    r8,[rax+rsi*1]
 47d:	4c 39 c6             	cmp    rsi,r8
 480:	0f 83 6d 01 00 00    	jae    5f3 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x1c3>
 486:	48 0f af f3          	imul   rsi,rbx
 48a:	49 8b 55 00          	mov    rdx,QWORD PTR [r13+0x0]
 48e:	48 8b 3d 00 00 00 00 	mov    rdi,QWORD PTR [rip+0x0]        # 495 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x65>	491: R_X86_64_PC32	a-0x4
 495:	4c 0f af c3          	imul   r8,rbx
 499:	4c 8d 0c dd 00 00 00 00 	lea    r9,[rbx*8+0x0]
 4a1:	c5 fd 6f 05 00 00 00 00 	vmovdqa ymm0,YMMWORD PTR [rip+0x0]        # 4a9 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x79>	4a5: R_X86_64_PC32	.LC1-0x4
 4a9:	4c 8d 52 ff          	lea    r10,[rdx-0x1]
 4ad:	48 8d 0c f7          	lea    rcx,[rdi+rsi*8]
 4b1:	e9 01 01 00 00       	jmp    5b7 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x187>
 4b6:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
        for(uint64_t j = 0; j < L; j++) {
 4c0:	48 89 d0             	mov    rax,rdx
 4c3:	48 83 f8 01          	cmp    rax,0x1
            a[i+j] = 7;
 4c7:	48 c7 01 07 00 00 00 	mov    QWORD PTR [rcx],0x7
 4ce:	0f 84 2c 01 00 00    	je     600 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x1d0>
 4d4:	48 83 f8 02          	cmp    rax,0x2
 4d8:	48 c7 41 08 07 00 00 00 	mov    QWORD PTR [rcx+0x8],0x7
 4e0:	0f 84 5a 01 00 00    	je     640 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x210>
 4e6:	48 83 f8 03          	cmp    rax,0x3
 4ea:	48 c7 41 10 07 00 00 00 	mov    QWORD PTR [rcx+0x10],0x7
 4f2:	0f 84 38 01 00 00    	je     630 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x200>
 4f8:	48 83 f8 04          	cmp    rax,0x4
 4fc:	48 c7 41 18 07 00 00 00 	mov    QWORD PTR [rcx+0x18],0x7
 504:	0f 84 16 01 00 00    	je     620 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x1f0>
 50a:	48 83 f8 05          	cmp    rax,0x5
 50e:	48 c7 41 20 07 00 00 00 	mov    QWORD PTR [rcx+0x20],0x7
 516:	0f 84 f4 00 00 00    	je     610 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x1e0>
 51c:	48 c7 41 28 07 00 00 00 	mov    QWORD PTR [rcx+0x28],0x7
double w_tile(uint64_t L, uint64_t K){
//double w_tile(){
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
 524:	41 bb 06 00 00 00    	mov    r11d,0x6
 52a:	48 39 c2             	cmp    rdx,rax
 52d:	74 7d                	je     5ac <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x17c>
 52f:	49 89 d5             	mov    r13,rdx
 532:	4d 89 d7             	mov    r15,r10
 535:	49 29 c5             	sub    r13,rax
 538:	49 29 c7             	sub    r15,rax
 53b:	4d 8d 65 fc          	lea    r12,[r13-0x4]
 53f:	49 c1 ec 02          	shr    r12,0x2
 543:	49 83 c4 01          	add    r12,0x1
 547:	49 83 ff 02          	cmp    r15,0x2
 54b:	4e 8d 34 a5 00 00 00 00 	lea    r14,[r12*4+0x0]
 553:	76 23                	jbe    578 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x148>
 555:	48 01 f0             	add    rax,rsi
 558:	4c 8d 3c c7          	lea    r15,[rdi+rax*8]
 55c:	31 c0                	xor    eax,eax
 55e:	48 83 c0 01          	add    rax,0x1
            a[i+j] = 7;
 562:	c4 c1 7d 7f 07       	vmovdqa YMMWORD PTR [r15],ymm0
 567:	49 83 c7 20          	add    r15,0x20
 56b:	49 39 c4             	cmp    r12,rax
 56e:	77 ee                	ja     55e <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x12e>
 570:	4d 01 f3             	add    r11,r14
 573:	4d 39 f5             	cmp    r13,r14
 576:	74 34                	je     5ac <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x17c>
 578:	4a 8d 04 1e          	lea    rax,[rsi+r11*1]
 57c:	48 c7 04 c7 07 00 00 00 	mov    QWORD PTR [rdi+rax*8],0x7
double w_tile(uint64_t L, uint64_t K){
//double w_tile(){
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
 584:	49 8d 43 01          	lea    rax,[r11+0x1]
 588:	48 39 d0             	cmp    rax,rdx
 58b:	73 1f                	jae    5ac <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x17c>
 58d:	49 83 c3 02          	add    r11,0x2
            a[i+j] = 7;
 591:	48 01 f0             	add    rax,rsi
double w_tile(uint64_t L, uint64_t K){
//double w_tile(){
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
 594:	4c 39 da             	cmp    rdx,r11
            a[i+j] = 7;
 597:	48 c7 04 c7 07 00 00 00 	mov    QWORD PTR [rdi+rax*8],0x7
double w_tile(uint64_t L, uint64_t K){
//double w_tile(){
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
 59f:	76 0b                	jbe    5ac <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x17c>
            a[i+j] = 7;
 5a1:	49 01 f3             	add    r11,rsi
 5a4:	4a c7 04 df 07 00 00 00 	mov    QWORD PTR [rdi+r11*8],0x7
 5ac:	48 01 de             	add    rsi,rbx
 5af:	4c 01 c9             	add    rcx,r9
 5b2:	49 39 f0             	cmp    r8,rsi
 5b5:	76 39                	jbe    5f0 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x1c0>
double w_tile(uint64_t L, uint64_t K){
//double w_tile(){
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
 5b7:	48 85 d2             	test   rdx,rdx
 5ba:	74 f0                	je     5ac <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x17c>
 5bc:	48 89 c8             	mov    rax,rcx
 5bf:	83 e0 1f             	and    eax,0x1f
 5c2:	48 c1 e8 03          	shr    rax,0x3
 5c6:	48 f7 d8             	neg    rax
 5c9:	83 e0 03             	and    eax,0x3
 5cc:	48 39 d0             	cmp    rax,rdx
 5cf:	48 0f 47 c2          	cmova  rax,rdx
 5d3:	48 83 fa 06          	cmp    rdx,0x6
 5d7:	0f 86 e3 fe ff ff    	jbe    4c0 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x90>
 5dd:	48 85 c0             	test   rax,rax
 5e0:	0f 85 dd fe ff ff    	jne    4c3 <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x93>
 5e6:	45 31 db             	xor    r11d,r11d
 5e9:	e9 41 ff ff ff       	jmp    52f <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0xff>
 5ee:	66 90                	xchg   ax,ax
 5f0:	c5 f8 77             	vzeroupper 
}

double w_tile(uint64_t L, uint64_t K){
//double w_tile(){
    double elapsed = get_time();
    #pragma omp parallel for
 5f3:	5b                   	pop    rbx
 5f4:	41 5a                	pop    r10
 5f6:	41 5c                	pop    r12
 5f8:	41 5d                	pop    r13
 5fa:	41 5e                	pop    r14
 5fc:	41 5f                	pop    r15
 5fe:	5d                   	pop    rbp
 5ff:	c3                   	ret    
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
 600:	41 bb 01 00 00 00    	mov    r11d,0x1
 606:	e9 1f ff ff ff       	jmp    52a <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0xfa>
 60b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
 610:	41 bb 05 00 00 00    	mov    r11d,0x5
 616:	e9 0f ff ff ff       	jmp    52a <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0xfa>
 61b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
 620:	41 bb 04 00 00 00    	mov    r11d,0x4
 626:	e9 ff fe ff ff       	jmp    52a <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0xfa>
 62b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
 630:	41 bb 03 00 00 00    	mov    r11d,0x3
 636:	e9 ef fe ff ff       	jmp    52a <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0xfa>
 63b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
 640:	41 bb 02 00 00 00    	mov    r11d,0x2
 646:	e9 df fe ff ff       	jmp    52a <w_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0xfa>
 64b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000000650 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]>:
    return get_time() - elapsed;
}

double w_dma(data_t** addr, uint64_t* len, uint64_t count) {
    double elapsed = get_time();
    #pragma omp parallel for
 650:	55                   	push   rbp
 651:	48 89 e5             	mov    rbp,rsp
 654:	41 56                	push   r14
 656:	41 55                	push   r13
 658:	41 54                	push   r12
 65a:	41 52                	push   r10
 65c:	53                   	push   rbx
 65d:	48 83 ec 08          	sub    rsp,0x8
    for(uint64_t i = 0; i < count; i++) {
 661:	48 8b 5f 10          	mov    rbx,QWORD PTR [rdi+0x10]
 665:	48 85 db             	test   rbx,rbx
 668:	0f 84 9d 01 00 00    	je     80b <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x1bb>
 66e:	49 89 fc             	mov    r12,rdi
 671:	e8 00 00 00 00       	call   676 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x26>	672: R_X86_64_PC32	omp_get_num_threads-0x4
 676:	4c 63 e8             	movsxd r13,eax
 679:	e8 00 00 00 00       	call   67e <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x2e>	67a: R_X86_64_PC32	omp_get_thread_num-0x4
 67e:	31 d2                	xor    edx,edx
 680:	4c 63 c0             	movsxd r8,eax
 683:	48 89 d8             	mov    rax,rbx
 686:	49 f7 f5             	div    r13
 689:	49 39 d0             	cmp    r8,rdx
 68c:	73 06                	jae    694 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x44>
 68e:	48 83 c0 01          	add    rax,0x1
 692:	31 d2                	xor    edx,edx
 694:	4c 0f af c0          	imul   r8,rax
 698:	49 01 d0             	add    r8,rdx
 69b:	4e 8d 14 00          	lea    r10,[rax+r8*1]
 69f:	4d 39 d0             	cmp    r8,r10
 6a2:	0f 83 63 01 00 00    	jae    80b <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x1bb>
 6a8:	49 8b 5c 24 08       	mov    rbx,QWORD PTR [r12+0x8]
 6ad:	4d 8b 1c 24          	mov    r11,QWORD PTR [r12]
 6b1:	c5 fd 6f 05 00 00 00 00 	vmovdqa ymm0,YMMWORD PTR [rip+0x0]        # 6b9 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x69>	6b5: R_X86_64_PC32	.LC1-0x4
 6b9:	e9 05 01 00 00       	jmp    7c3 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x173>
 6be:	66 90                	xchg   ax,ax
        const uint64_t c_len = len[i];
        data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
 6c0:	48 89 c8             	mov    rax,rcx
 6c3:	48 83 f8 01          	cmp    rax,0x1
            *c_addr++ = 7;
 6c7:	48 8d 72 08          	lea    rsi,[rdx+0x8]
 6cb:	48 c7 02 07 00 00 00 	mov    QWORD PTR [rdx],0x7
 6d2:	0f 84 48 01 00 00    	je     820 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x1d0>
 6d8:	48 83 f8 02          	cmp    rax,0x2
 6dc:	48 8d 72 10          	lea    rsi,[rdx+0x10]
 6e0:	48 c7 42 08 07 00 00 00 	mov    QWORD PTR [rdx+0x8],0x7
 6e8:	0f 84 72 01 00 00    	je     860 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x210>
 6ee:	48 83 f8 03          	cmp    rax,0x3
 6f2:	48 8d 72 18          	lea    rsi,[rdx+0x18]
 6f6:	48 c7 42 10 07 00 00 00 	mov    QWORD PTR [rdx+0x10],0x7
 6fe:	0f 84 4c 01 00 00    	je     850 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x200>
 704:	48 83 f8 04          	cmp    rax,0x4
 708:	48 8d 72 20          	lea    rsi,[rdx+0x20]
 70c:	48 c7 42 18 07 00 00 00 	mov    QWORD PTR [rdx+0x18],0x7
 714:	0f 84 26 01 00 00    	je     840 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x1f0>
 71a:	48 83 f8 05          	cmp    rax,0x5
 71e:	48 8d 72 28          	lea    rsi,[rdx+0x28]
 722:	48 c7 42 20 07 00 00 00 	mov    QWORD PTR [rdx+0x20],0x7
 72a:	0f 84 00 01 00 00    	je     830 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x1e0>
 730:	48 8d 72 30          	lea    rsi,[rdx+0x30]
 734:	48 c7 42 28 07 00 00 00 	mov    QWORD PTR [rdx+0x28],0x7
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < count; i++) {
        const uint64_t c_len = len[i];
        data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
 73c:	41 b9 06 00 00 00    	mov    r9d,0x6
 742:	48 39 c8             	cmp    rax,rcx
 745:	74 73                	je     7ba <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x16a>
 747:	49 89 cd             	mov    r13,rcx
 74a:	4c 8d 71 ff          	lea    r14,[rcx-0x1]
 74e:	49 29 c5             	sub    r13,rax
 751:	49 8d 7d fc          	lea    rdi,[r13-0x4]
 755:	49 29 c6             	sub    r14,rax
 758:	48 c1 ef 02          	shr    rdi,0x2
 75c:	48 83 c7 01          	add    rdi,0x1
 760:	49 83 fe 02          	cmp    r14,0x2
 764:	4c 8d 24 bd 00 00 00 00 	lea    r12,[rdi*4+0x0]
 76c:	76 23                	jbe    791 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x141>
 76e:	48 8d 14 c2          	lea    rdx,[rdx+rax*8]
 772:	31 c0                	xor    eax,eax
 774:	48 83 c0 01          	add    rax,0x1
            *c_addr++ = 7;
 778:	c5 fd 7f 02          	vmovdqa YMMWORD PTR [rdx],ymm0
 77c:	48 83 c2 20          	add    rdx,0x20
 780:	48 39 c7             	cmp    rdi,rax
 783:	77 ef                	ja     774 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x124>
 785:	4d 01 e1             	add    r9,r12
 788:	4d 39 e5             	cmp    r13,r12
 78b:	4a 8d 34 e6          	lea    rsi,[rsi+r12*8]
 78f:	74 29                	je     7ba <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x16a>
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < count; i++) {
        const uint64_t c_len = len[i];
        data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
 791:	49 8d 41 01          	lea    rax,[r9+0x1]
            *c_addr++ = 7;
 795:	48 c7 06 07 00 00 00 	mov    QWORD PTR [rsi],0x7
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < count; i++) {
        const uint64_t c_len = len[i];
        data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
 79c:	48 39 c1             	cmp    rcx,rax
 79f:	76 19                	jbe    7ba <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x16a>
 7a1:	49 83 c1 02          	add    r9,0x2
            *c_addr++ = 7;
 7a5:	48 c7 46 08 07 00 00 00 	mov    QWORD PTR [rsi+0x8],0x7
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < count; i++) {
        const uint64_t c_len = len[i];
        data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
 7ad:	4c 39 c9             	cmp    rcx,r9
 7b0:	76 08                	jbe    7ba <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x16a>
            *c_addr++ = 7;
 7b2:	48 c7 46 10 07 00 00 00 	mov    QWORD PTR [rsi+0x10],0x7
 7ba:	49 83 c0 01          	add    r8,0x1
 7be:	4d 39 c2             	cmp    r10,r8
 7c1:	74 45                	je     808 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x1b8>

double w_dma(data_t** addr, uint64_t* len, uint64_t count) {
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < count; i++) {
        const uint64_t c_len = len[i];
 7c3:	4a 8b 0c c3          	mov    rcx,QWORD PTR [rbx+r8*8]
        data_t* c_addr = addr[i];
 7c7:	4b 8b 14 c3          	mov    rdx,QWORD PTR [r11+r8*8]
        for(uint64_t j = 0; j < c_len; j++) {
 7cb:	48 85 c9             	test   rcx,rcx
 7ce:	74 ea                	je     7ba <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x16a>
 7d0:	48 89 d0             	mov    rax,rdx
 7d3:	83 e0 1f             	and    eax,0x1f
 7d6:	48 c1 e8 03          	shr    rax,0x3
 7da:	48 f7 d8             	neg    rax
 7dd:	83 e0 03             	and    eax,0x3
 7e0:	48 39 c8             	cmp    rax,rcx
 7e3:	48 0f 47 c1          	cmova  rax,rcx
 7e7:	48 83 f9 06          	cmp    rcx,0x6
 7eb:	0f 86 cf fe ff ff    	jbe    6c0 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x70>
 7f1:	48 85 c0             	test   rax,rax
 7f4:	0f 85 c9 fe ff ff    	jne    6c3 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x73>
double w_dma(data_t** addr, uint64_t* len, uint64_t count) {
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < count; i++) {
        const uint64_t c_len = len[i];
        data_t* c_addr = addr[i];
 7fa:	48 89 d6             	mov    rsi,rdx
        for(uint64_t j = 0; j < c_len; j++) {
 7fd:	45 31 c9             	xor    r9d,r9d
 800:	e9 42 ff ff ff       	jmp    747 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0xf7>
 805:	0f 1f 00             	nop    DWORD PTR [rax]
 808:	c5 f8 77             	vzeroupper 
    return get_time() - elapsed;
}

double w_dma(data_t** addr, uint64_t* len, uint64_t count) {
    double elapsed = get_time();
    #pragma omp parallel for
 80b:	48 83 c4 08          	add    rsp,0x8
 80f:	5b                   	pop    rbx
 810:	41 5a                	pop    r10
 812:	41 5c                	pop    r12
 814:	41 5d                	pop    r13
 816:	41 5e                	pop    r14
 818:	5d                   	pop    rbp
 819:	c3                   	ret    
 81a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    for(uint64_t i = 0; i < count; i++) {
        const uint64_t c_len = len[i];
        data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
 820:	41 b9 01 00 00 00    	mov    r9d,0x1
 826:	e9 17 ff ff ff       	jmp    742 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0xf2>
 82b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
 830:	41 b9 05 00 00 00    	mov    r9d,0x5
 836:	e9 07 ff ff ff       	jmp    742 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0xf2>
 83b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
 840:	41 b9 04 00 00 00    	mov    r9d,0x4
 846:	e9 f7 fe ff ff       	jmp    742 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0xf2>
 84b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
 850:	41 b9 03 00 00 00    	mov    r9d,0x3
 856:	e9 e7 fe ff ff       	jmp    742 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0xf2>
 85b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
 860:	41 b9 02 00 00 00    	mov    r9d,0x2
 866:	e9 d7 fe ff ff       	jmp    742 <w_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0xf2>
 86b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000000870 <w_seq_memset()>:
#include "common.h"

using namespace std;

double w_seq_memset(){
 870:	48 83 ec 18          	sub    rsp,0x18
    volatile data_t* vol_a = a;
    double elapsed = get_time();
 874:	e8 00 00 00 00       	call   879 <w_seq_memset()+0x9>	875: R_X86_64_PC32	get_time()-0x4
 879:	31 c9                	xor    ecx,ecx
 87b:	31 d2                	xor    edx,edx
 87d:	31 f6                	xor    esi,esi
 87f:	bf 00 00 00 00       	mov    edi,0x0	880: R_X86_64_32	.text
 884:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 88a:	e8 00 00 00 00       	call   88f <w_seq_memset()+0x1f>	88b: R_X86_64_PC32	GOMP_parallel-0x4
        uint64_t tid = omp_get_thread_num();
        uint64_t elem_per_thread = HS_ARRAY_ELEM / omp_get_num_threads();
        uint64_t offset = tid * elem_per_thread;        
        memset(a + offset, 7, elem_per_thread * sizeof(data_t));
    }
    return get_time() - elapsed;
 88f:	e8 00 00 00 00       	call   894 <w_seq_memset()+0x24>	890: R_X86_64_PC32	get_time()-0x4
 894:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 89a:	48 83 c4 18          	add    rsp,0x18
 89e:	c3                   	ret    
 89f:	90                   	nop

00000000000008a0 <w_seq_fill()>:

double w_seq_fill(){
 8a0:	48 83 ec 18          	sub    rsp,0x18
    //volatile data_t* vol_a = a;
    double elapsed = get_time();
 8a4:	e8 00 00 00 00       	call   8a9 <w_seq_fill()+0x9>	8a5: R_X86_64_PC32	get_time()-0x4
 8a9:	31 c9                	xor    ecx,ecx
 8ab:	31 d2                	xor    edx,edx
 8ad:	31 f6                	xor    esi,esi
 8af:	bf 00 00 00 00       	mov    edi,0x0	8b0: R_X86_64_32	.text+0x50
 8b4:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 8ba:	e8 00 00 00 00       	call   8bf <w_seq_fill()+0x1f>	8bb: R_X86_64_PC32	GOMP_parallel-0x4
    //#pragma omp parallel for
    #pragma omp parallel for simd aligned(a: 32)
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        a[i] = 7;
    }
    return get_time() - elapsed;
 8bf:	e8 00 00 00 00       	call   8c4 <w_seq_fill()+0x24>	8c0: R_X86_64_PC32	get_time()-0x4
 8c4:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 8ca:	48 83 c4 18          	add    rsp,0x18
 8ce:	c3                   	ret    
 8cf:	90                   	nop

00000000000008d0 <w_rand_ind()>:

double w_rand_ind(){
 8d0:	48 83 ec 18          	sub    rsp,0x18
    //volatile data_t * vol_a = a;
    double elapsed = get_time();
 8d4:	e8 00 00 00 00       	call   8d9 <w_rand_ind()+0x9>	8d5: R_X86_64_PC32	get_time()-0x4
 8d9:	31 c9                	xor    ecx,ecx
 8db:	31 d2                	xor    edx,edx
 8dd:	31 f6                	xor    esi,esi
 8df:	bf 00 00 00 00       	mov    edi,0x0	8e0: R_X86_64_32	.text+0x1e0
 8e4:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 8ea:	e8 00 00 00 00       	call   8ef <w_rand_ind()+0x1f>	8eb: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        uint64_t idx = ((i * 0xDEADBEEF) ^ 0xC0FFEE0B) % HS_ARRAY_ELEM;
        a[idx] = 7;
    }
    return get_time() - elapsed;
 8ef:	e8 00 00 00 00       	call   8f4 <w_rand_ind()+0x24>	8f0: R_X86_64_PC32	get_time()-0x4
 8f4:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 8fa:	48 83 c4 18          	add    rsp,0x18
 8fe:	c3                   	ret    
 8ff:	90                   	nop

0000000000000900 <w_stride_2()>:

double w_stride_2(){
 900:	48 83 ec 18          	sub    rsp,0x18
    double elapsed = get_time();
 904:	e8 00 00 00 00       	call   909 <w_stride_2()+0x9>	905: R_X86_64_PC32	get_time()-0x4
 909:	31 c9                	xor    ecx,ecx
 90b:	31 d2                	xor    edx,edx
 90d:	31 f6                	xor    esi,esi
 90f:	bf 00 00 00 00       	mov    edi,0x0	910: R_X86_64_32	.text+0x250
 914:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 91a:	e8 00 00 00 00       	call   91f <w_stride_2()+0x1f>	91b: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 2) {
        a[i] = 7;
    }
    return get_time() - elapsed;
 91f:	e8 00 00 00 00       	call   924 <w_stride_2()+0x24>	920: R_X86_64_PC32	get_time()-0x4
 924:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 92a:	48 83 c4 18          	add    rsp,0x18
 92e:	c3                   	ret    
 92f:	90                   	nop

0000000000000930 <w_stride_4()>:

double w_stride_4(){
 930:	48 83 ec 18          	sub    rsp,0x18
    double elapsed = get_time();
 934:	e8 00 00 00 00       	call   939 <w_stride_4()+0x9>	935: R_X86_64_PC32	get_time()-0x4
 939:	31 c9                	xor    ecx,ecx
 93b:	31 d2                	xor    edx,edx
 93d:	31 f6                	xor    esi,esi
 93f:	bf 00 00 00 00       	mov    edi,0x0	940: R_X86_64_32	.text+0x2b0
 944:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 94a:	e8 00 00 00 00       	call   94f <w_stride_4()+0x1f>	94b: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 4) {
        a[i] = 7;
    }
    return get_time() - elapsed;
 94f:	e8 00 00 00 00       	call   954 <w_stride_4()+0x24>	950: R_X86_64_PC32	get_time()-0x4
 954:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 95a:	48 83 c4 18          	add    rsp,0x18
 95e:	c3                   	ret    
 95f:	90                   	nop

0000000000000960 <w_stride_8()>:

double w_stride_8(){
 960:	48 83 ec 18          	sub    rsp,0x18
    double elapsed = get_time();
 964:	e8 00 00 00 00       	call   969 <w_stride_8()+0x9>	965: R_X86_64_PC32	get_time()-0x4
 969:	31 c9                	xor    ecx,ecx
 96b:	31 d2                	xor    edx,edx
 96d:	31 f6                	xor    esi,esi
 96f:	bf 00 00 00 00       	mov    edi,0x0	970: R_X86_64_32	.text+0x310
 974:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 97a:	e8 00 00 00 00       	call   97f <w_stride_8()+0x1f>	97b: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 8) {
        a[i] = 7;
    }
    return get_time() - elapsed;
 97f:	e8 00 00 00 00       	call   984 <w_stride_8()+0x24>	980: R_X86_64_PC32	get_time()-0x4
 984:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 98a:	48 83 c4 18          	add    rsp,0x18
 98e:	c3                   	ret    
 98f:	90                   	nop

0000000000000990 <w_stride_16()>:

double w_stride_16(){
 990:	48 83 ec 18          	sub    rsp,0x18
    double elapsed = get_time();
 994:	e8 00 00 00 00       	call   999 <w_stride_16()+0x9>	995: R_X86_64_PC32	get_time()-0x4
 999:	31 c9                	xor    ecx,ecx
 99b:	31 d2                	xor    edx,edx
 99d:	31 f6                	xor    esi,esi
 99f:	bf 00 00 00 00       	mov    edi,0x0	9a0: R_X86_64_32	.text+0x370
 9a4:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 9aa:	e8 00 00 00 00       	call   9af <w_stride_16()+0x1f>	9ab: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 16) {
        a[i] = 7;
    }
    return get_time() - elapsed;
 9af:	e8 00 00 00 00       	call   9b4 <w_stride_16()+0x24>	9b0: R_X86_64_PC32	get_time()-0x4
 9b4:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 9ba:	48 83 c4 18          	add    rsp,0x18
 9be:	c3                   	ret    
 9bf:	90                   	nop

00000000000009c0 <w_stride_32()>:

double w_stride_32(){
 9c0:	48 83 ec 18          	sub    rsp,0x18
    double elapsed = get_time();
 9c4:	e8 00 00 00 00       	call   9c9 <w_stride_32()+0x9>	9c5: R_X86_64_PC32	get_time()-0x4
 9c9:	31 c9                	xor    ecx,ecx
 9cb:	31 d2                	xor    edx,edx
 9cd:	31 f6                	xor    esi,esi
 9cf:	bf 00 00 00 00       	mov    edi,0x0	9d0: R_X86_64_32	.text+0x3d0
 9d4:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 9da:	e8 00 00 00 00       	call   9df <w_stride_32()+0x1f>	9db: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 32) {
        a[i] = 7;
    }
    return get_time() - elapsed;
 9df:	e8 00 00 00 00       	call   9e4 <w_stride_32()+0x24>	9e0: R_X86_64_PC32	get_time()-0x4
 9e4:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 9ea:	48 83 c4 18          	add    rsp,0x18
 9ee:	c3                   	ret    
 9ef:	90                   	nop

00000000000009f0 <w_tile(unsigned long, unsigned long)>:

double w_tile(uint64_t L, uint64_t K){
 9f0:	55                   	push   rbp
 9f1:	53                   	push   rbx
 9f2:	48 89 fd             	mov    rbp,rdi
 9f5:	48 89 f3             	mov    rbx,rsi
 9f8:	48 83 ec 38          	sub    rsp,0x38
 9fc:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 a05:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
 a0a:	31 c0                	xor    eax,eax
//double w_tile(){
    double elapsed = get_time();
 a0c:	e8 00 00 00 00       	call   a11 <w_tile(unsigned long, unsigned long)+0x21>	a0d: R_X86_64_PC32	get_time()-0x4
 a11:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
 a16:	31 c9                	xor    ecx,ecx
 a18:	31 d2                	xor    edx,edx
 a1a:	bf 00 00 00 00       	mov    edi,0x0	a1b: R_X86_64_32	.text+0x430
 a1f:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
    #pragma omp parallel for
 a25:	48 89 6c 24 10       	mov    QWORD PTR [rsp+0x10],rbp
 a2a:	48 89 5c 24 18       	mov    QWORD PTR [rsp+0x18],rbx
 a2f:	e8 00 00 00 00       	call   a34 <w_tile(unsigned long, unsigned long)+0x44>	a30: R_X86_64_PC32	GOMP_parallel-0x4
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
            a[i+j] = 7;
        }
    }
    return get_time() - elapsed;
 a34:	e8 00 00 00 00       	call   a39 <w_tile(unsigned long, unsigned long)+0x49>	a35: R_X86_64_PC32	get_time()-0x4
}
 a39:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
 a3e:	64 48 33 04 25 28 00 00 00 	xor    rax,QWORD PTR fs:0x28
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
            a[i+j] = 7;
        }
    }
    return get_time() - elapsed;
 a47:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 a4d:	75 07                	jne    a56 <w_tile(unsigned long, unsigned long)+0x66>
 a4f:	48 83 c4 38          	add    rsp,0x38
 a53:	5b                   	pop    rbx
 a54:	5d                   	pop    rbp
 a55:	c3                   	ret    
 a56:	e8 00 00 00 00       	call   a5b <w_tile(unsigned long, unsigned long)+0x6b>	a57: R_X86_64_PC32	__stack_chk_fail-0x4
 a5b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000000a60 <w_dma(unsigned long**, unsigned long*, unsigned long)>:

double w_dma(data_t** addr, uint64_t* len, uint64_t count) {
 a60:	41 54                	push   r12
 a62:	55                   	push   rbp
 a63:	49 89 fc             	mov    r12,rdi
 a66:	53                   	push   rbx
 a67:	48 89 f5             	mov    rbp,rsi
 a6a:	48 89 d3             	mov    rbx,rdx
 a6d:	48 83 ec 30          	sub    rsp,0x30
 a71:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 a7a:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
 a7f:	31 c0                	xor    eax,eax
    double elapsed = get_time();
 a81:	e8 00 00 00 00       	call   a86 <w_dma(unsigned long**, unsigned long*, unsigned long)+0x26>	a82: R_X86_64_PC32	get_time()-0x4
 a86:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
 a8b:	31 c9                	xor    ecx,ecx
 a8d:	31 d2                	xor    edx,edx
 a8f:	bf 00 00 00 00       	mov    edi,0x0	a90: R_X86_64_32	.text+0x650
 a94:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
    #pragma omp parallel for
 a9a:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
 a9f:	48 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],rbp
 aa4:	48 89 5c 24 20       	mov    QWORD PTR [rsp+0x20],rbx
 aa9:	e8 00 00 00 00       	call   aae <w_dma(unsigned long**, unsigned long*, unsigned long)+0x4e>	aaa: R_X86_64_PC32	GOMP_parallel-0x4
        data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
            *c_addr++ = 7;
        }
    }
    return get_time() - elapsed;
 aae:	e8 00 00 00 00       	call   ab3 <w_dma(unsigned long**, unsigned long*, unsigned long)+0x53>	aaf: R_X86_64_PC32	get_time()-0x4
}
 ab3:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
 ab8:	64 48 33 04 25 28 00 00 00 	xor    rax,QWORD PTR fs:0x28
        data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
            *c_addr++ = 7;
        }
    }
    return get_time() - elapsed;
 ac1:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 ac7:	75 09                	jne    ad2 <w_dma(unsigned long**, unsigned long*, unsigned long)+0x72>
 ac9:	48 83 c4 30          	add    rsp,0x30
 acd:	5b                   	pop    rbx
 ace:	5d                   	pop    rbp
 acf:	41 5c                	pop    r12
 ad1:	c3                   	ret    
 ad2:	e8 00 00 00 00       	call   ad7 <w_dma(unsigned long**, unsigned long*, unsigned long)+0x77>	ad3: R_X86_64_PC32	__stack_chk_fail-0x4
