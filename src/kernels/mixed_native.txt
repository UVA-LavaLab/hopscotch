
mixed_kernels.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <rw_seq_copy() [clone ._omp_fn.0]>:
#include "common.h"
#include <string.h>

double rw_seq_copy(){
    double elapsed = get_time();
    #pragma omp parallel for
   0:	4c 8d 54 24 08       	lea    r10,[rsp+0x8]
   5:	48 83 e4 e0          	and    rsp,0xffffffffffffffe0
   9:	41 ff 72 f8          	push   QWORD PTR [r10-0x8]
   d:	55                   	push   rbp
   e:	48 89 e5             	mov    rbp,rsp
  11:	41 54                	push   r12
  13:	41 52                	push   r10
  15:	53                   	push   rbx
  16:	48 83 ec 18          	sub    rsp,0x18
  1a:	e8 00 00 00 00       	call   1f <rw_seq_copy() [clone ._omp_fn.0]+0x1f>	1b: R_X86_64_PC32	omp_get_num_threads-0x4
  1f:	48 63 d8             	movsxd rbx,eax
  22:	e8 00 00 00 00       	call   27 <rw_seq_copy() [clone ._omp_fn.0]+0x27>	23: R_X86_64_PC32	omp_get_thread_num-0x4
  27:	31 d2                	xor    edx,edx
  29:	48 63 c8             	movsxd rcx,eax
  2c:	b8 00 00 00 04       	mov    eax,0x4000000
  31:	48 f7 f3             	div    rbx
  34:	48 39 d1             	cmp    rcx,rdx
  37:	73 06                	jae    3f <rw_seq_copy() [clone ._omp_fn.0]+0x3f>
  39:	48 83 c0 01          	add    rax,0x1
  3d:	31 d2                	xor    edx,edx
  3f:	48 89 ce             	mov    rsi,rcx
  42:	48 0f af f0          	imul   rsi,rax
  46:	48 8d 0c 32          	lea    rcx,[rdx+rsi*1]
  4a:	4c 8d 0c 08          	lea    r9,[rax+rcx*1]
  4e:	4c 39 c9             	cmp    rcx,r9
  51:	0f 83 1c 01 00 00    	jae    173 <rw_seq_copy() [clone ._omp_fn.0]+0x173>
  57:	48 8b 3d 00 00 00 00 	mov    rdi,QWORD PTR [rip+0x0]        # 5e <rw_seq_copy() [clone ._omp_fn.0]+0x5e>	5a: R_X86_64_PC32	a-0x4
  5e:	4c 8b 05 00 00 00 00 	mov    r8,QWORD PTR [rip+0x0]        # 65 <rw_seq_copy() [clone ._omp_fn.0]+0x65>	61: R_X86_64_PC32	b-0x4
  65:	48 8d 54 32 04       	lea    rdx,[rdx+rsi*1+0x4]
  6a:	4c 8d 14 cd 00 00 00 00 	lea    r10,[rcx*8+0x0]
  72:	48 c1 e2 03          	shl    rdx,0x3
  76:	48 8d 34 17          	lea    rsi,[rdi+rdx*1]
  7a:	4f 8d 1c 10          	lea    r11,[r8+r10*1]
  7e:	4a 8d 1c 17          	lea    rbx,[rdi+r10*1]
  82:	49 39 f3             	cmp    r11,rsi
  85:	40 0f 93 c6          	setae  sil
  89:	4c 01 c2             	add    rdx,r8
  8c:	48 39 d3             	cmp    rbx,rdx
  8f:	0f 93 c2             	setae  dl
  92:	40 08 d6             	or     sil,dl
  95:	0f 84 ed 00 00 00    	je     188 <rw_seq_copy() [clone ._omp_fn.0]+0x188>
  9b:	48 83 f8 0c          	cmp    rax,0xc
  9f:	0f 86 e3 00 00 00    	jbe    188 <rw_seq_copy() [clone ._omp_fn.0]+0x188>
  a5:	4c 89 de             	mov    rsi,r11
  a8:	83 e6 1f             	and    esi,0x1f
  ab:	48 c1 ee 03          	shr    rsi,0x3
  af:	48 f7 de             	neg    rsi
  b2:	83 e6 03             	and    esi,0x3
  b5:	48 39 c6             	cmp    rsi,rax
  b8:	48 0f 47 f0          	cmova  rsi,rax
  bc:	48 85 f6             	test   rsi,rsi
  bf:	74 36                	je     f7 <rw_seq_copy() [clone ._omp_fn.0]+0xf7>
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        a[i] = b[i];
  c1:	49 8b 13             	mov    rdx,QWORD PTR [r11]
  c4:	48 83 fe 01          	cmp    rsi,0x1
  c8:	48 89 13             	mov    QWORD PTR [rbx],rdx
  cb:	48 8d 51 01          	lea    rdx,[rcx+0x1]
  cf:	0f 84 e3 00 00 00    	je     1b8 <rw_seq_copy() [clone ._omp_fn.0]+0x1b8>
  d5:	4d 8b 1c d0          	mov    r11,QWORD PTR [r8+rdx*8]
  d9:	48 83 fe 03          	cmp    rsi,0x3
  dd:	4c 89 1c d7          	mov    QWORD PTR [rdi+rdx*8],r11
  e1:	48 8d 51 02          	lea    rdx,[rcx+0x2]
  e5:	0f 85 cd 00 00 00    	jne    1b8 <rw_seq_copy() [clone ._omp_fn.0]+0x1b8>
  eb:	4d 8b 1c d0          	mov    r11,QWORD PTR [r8+rdx*8]
  ef:	48 83 c1 03          	add    rcx,0x3
  f3:	4c 89 1c d7          	mov    QWORD PTR [rdi+rdx*8],r11
  f7:	48 29 f0             	sub    rax,rsi
  fa:	4d 8d 14 f2          	lea    r10,[r10+rsi*8]
  fe:	31 d2                	xor    edx,edx
 100:	4c 8d 58 fc          	lea    r11,[rax-0x4]
 104:	31 f6                	xor    esi,esi
 106:	4f 8d 24 10          	lea    r12,[r8+r10*1]
 10a:	49 01 fa             	add    r10,rdi
 10d:	49 c1 eb 02          	shr    r11,0x2
 111:	49 83 c3 01          	add    r11,0x1
 115:	4a 8d 1c 9d 00 00 00 00 	lea    rbx,[r11*4+0x0]
 11d:	c4 c1 7d 6f 04 34    	vmovdqa ymm0,YMMWORD PTR [r12+rsi*1]
 123:	48 83 c2 01          	add    rdx,0x1
 127:	c4 c1 78 11 04 32    	vmovups XMMWORD PTR [r10+rsi*1],xmm0
 12d:	c4 c3 7d 39 44 32 10 01 	vextracti128 XMMWORD PTR [r10+rsi*1+0x10],ymm0,0x1
 135:	48 83 c6 20          	add    rsi,0x20
 139:	4c 39 da             	cmp    rdx,r11
 13c:	72 df                	jb     11d <rw_seq_copy() [clone ._omp_fn.0]+0x11d>
 13e:	48 01 d9             	add    rcx,rbx
 141:	48 39 d8             	cmp    rax,rbx
 144:	74 5a                	je     1a0 <rw_seq_copy() [clone ._omp_fn.0]+0x1a0>
 146:	49 8b 04 c8          	mov    rax,QWORD PTR [r8+rcx*8]
 14a:	48 89 04 cf          	mov    QWORD PTR [rdi+rcx*8],rax
 14e:	48 8d 41 01          	lea    rax,[rcx+0x1]
 152:	49 39 c1             	cmp    r9,rax
 155:	76 49                	jbe    1a0 <rw_seq_copy() [clone ._omp_fn.0]+0x1a0>
 157:	49 8b 14 c0          	mov    rdx,QWORD PTR [r8+rax*8]
 15b:	48 83 c1 02          	add    rcx,0x2
 15f:	49 39 c9             	cmp    r9,rcx
 162:	48 89 14 c7          	mov    QWORD PTR [rdi+rax*8],rdx
 166:	76 38                	jbe    1a0 <rw_seq_copy() [clone ._omp_fn.0]+0x1a0>
 168:	49 8b 04 c8          	mov    rax,QWORD PTR [r8+rcx*8]
 16c:	48 89 04 cf          	mov    QWORD PTR [rdi+rcx*8],rax
 170:	c5 f8 77             	vzeroupper 
#include "common.h"
#include <string.h>

double rw_seq_copy(){
    double elapsed = get_time();
    #pragma omp parallel for
 173:	48 83 c4 18          	add    rsp,0x18
 177:	5b                   	pop    rbx
 178:	41 5a                	pop    r10
 17a:	41 5c                	pop    r12
 17c:	5d                   	pop    rbp
 17d:	49 8d 62 f8          	lea    rsp,[r10-0x8]
 181:	c3                   	ret    
 182:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        a[i] = b[i];
 188:	49 8b 04 c8          	mov    rax,QWORD PTR [r8+rcx*8]
 18c:	48 89 04 cf          	mov    QWORD PTR [rdi+rcx*8],rax
 190:	48 83 c1 01          	add    rcx,0x1
 194:	49 39 c9             	cmp    r9,rcx
 197:	75 ef                	jne    188 <rw_seq_copy() [clone ._omp_fn.0]+0x188>
 199:	eb d8                	jmp    173 <rw_seq_copy() [clone ._omp_fn.0]+0x173>
 19b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
 1a0:	c5 f8 77             	vzeroupper 
#include "common.h"
#include <string.h>

double rw_seq_copy(){
    double elapsed = get_time();
    #pragma omp parallel for
 1a3:	48 83 c4 18          	add    rsp,0x18
 1a7:	5b                   	pop    rbx
 1a8:	41 5a                	pop    r10
 1aa:	41 5c                	pop    r12
 1ac:	5d                   	pop    rbp
 1ad:	49 8d 62 f8          	lea    rsp,[r10-0x8]
 1b1:	c3                   	ret    
 1b2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        a[i] = b[i];
 1b8:	48 89 d1             	mov    rcx,rdx
 1bb:	e9 37 ff ff ff       	jmp    f7 <rw_seq_copy() [clone ._omp_fn.0]+0xf7>

00000000000001c0 <rw_seq_inc() [clone ._omp_fn.1]>:
    return get_time() - elapsed;
}

double rw_seq_inc(){
    double elapsed = get_time();
    #pragma omp parallel for
 1c0:	4c 8d 54 24 08       	lea    r10,[rsp+0x8]
 1c5:	48 83 e4 e0          	and    rsp,0xffffffffffffffe0
 1c9:	41 ff 72 f8          	push   QWORD PTR [r10-0x8]
 1cd:	55                   	push   rbp
 1ce:	48 89 e5             	mov    rbp,rsp
 1d1:	41 52                	push   r10
 1d3:	53                   	push   rbx
 1d4:	e8 00 00 00 00       	call   1d9 <rw_seq_inc() [clone ._omp_fn.1]+0x19>	1d5: R_X86_64_PC32	omp_get_num_threads-0x4
 1d9:	48 63 d8             	movsxd rbx,eax
 1dc:	e8 00 00 00 00       	call   1e1 <rw_seq_inc() [clone ._omp_fn.1]+0x21>	1dd: R_X86_64_PC32	omp_get_thread_num-0x4
 1e1:	31 d2                	xor    edx,edx
 1e3:	48 63 c8             	movsxd rcx,eax
 1e6:	b8 00 00 00 04       	mov    eax,0x4000000
 1eb:	48 f7 f3             	div    rbx
 1ee:	48 39 d1             	cmp    rcx,rdx
 1f1:	73 06                	jae    1f9 <rw_seq_inc() [clone ._omp_fn.1]+0x39>
 1f3:	48 83 c0 01          	add    rax,0x1
 1f7:	31 d2                	xor    edx,edx
 1f9:	48 0f af c8          	imul   rcx,rax
 1fd:	48 01 ca             	add    rdx,rcx
 200:	4c 8d 0c 10          	lea    r9,[rax+rdx*1]
 204:	4c 39 ca             	cmp    rdx,r9
 207:	0f 83 ea 00 00 00    	jae    2f7 <rw_seq_inc() [clone ._omp_fn.1]+0x137>
 20d:	48 8b 3d 00 00 00 00 	mov    rdi,QWORD PTR [rip+0x0]        # 214 <rw_seq_inc() [clone ._omp_fn.1]+0x54>	210: R_X86_64_PC32	a-0x4
 214:	48 8d 34 d7          	lea    rsi,[rdi+rdx*8]
 218:	48 89 f1             	mov    rcx,rsi
 21b:	83 e1 1f             	and    ecx,0x1f
 21e:	48 c1 e9 03          	shr    rcx,0x3
 222:	48 f7 d9             	neg    rcx
 225:	83 e1 03             	and    ecx,0x3
 228:	48 39 c1             	cmp    rcx,rax
 22b:	48 0f 47 c8          	cmova  rcx,rax
 22f:	48 83 f8 04          	cmp    rax,0x4
 233:	48 0f 46 c8          	cmovbe rcx,rax
 237:	48 85 c9             	test   rcx,rcx
 23a:	0f 84 c0 00 00 00    	je     300 <rw_seq_inc() [clone ._omp_fn.1]+0x140>
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        a[i]++;
 240:	48 83 06 01          	add    QWORD PTR [rsi],0x1
 244:	48 83 f9 01          	cmp    rcx,0x1
 248:	48 8d 72 01          	lea    rsi,[rdx+0x1]
 24c:	74 27                	je     275 <rw_seq_inc() [clone ._omp_fn.1]+0xb5>
 24e:	48 83 04 f7 01       	add    QWORD PTR [rdi+rsi*8],0x1
 253:	48 83 f9 02          	cmp    rcx,0x2
 257:	48 8d 72 02          	lea    rsi,[rdx+0x2]
 25b:	74 18                	je     275 <rw_seq_inc() [clone ._omp_fn.1]+0xb5>
 25d:	48 83 04 f7 01       	add    QWORD PTR [rdi+rsi*8],0x1
 262:	48 83 f9 04          	cmp    rcx,0x4
 266:	48 8d 72 03          	lea    rsi,[rdx+0x3]
 26a:	75 09                	jne    275 <rw_seq_inc() [clone ._omp_fn.1]+0xb5>
 26c:	48 83 04 f7 01       	add    QWORD PTR [rdi+rsi*8],0x1
 271:	48 8d 72 04          	lea    rsi,[rdx+0x4]
 275:	48 39 c8             	cmp    rax,rcx
 278:	74 7d                	je     2f7 <rw_seq_inc() [clone ._omp_fn.1]+0x137>
 27a:	49 89 c2             	mov    r10,rax
 27d:	48 83 e8 01          	sub    rax,0x1
 281:	49 29 ca             	sub    r10,rcx
 284:	48 29 c8             	sub    rax,rcx
 287:	4d 8d 42 fc          	lea    r8,[r10-0x4]
 28b:	49 c1 e8 02          	shr    r8,0x2
 28f:	49 83 c0 01          	add    r8,0x1
 293:	48 83 f8 02          	cmp    rax,0x2
 297:	4e 8d 1c 85 00 00 00 00 	lea    r11,[r8*4+0x0]
 29f:	76 35                	jbe    2d6 <rw_seq_inc() [clone ._omp_fn.1]+0x116>
 2a1:	48 01 ca             	add    rdx,rcx
 2a4:	c5 fd 6f 0d 00 00 00 00 	vmovdqa ymm1,YMMWORD PTR [rip+0x0]        # 2ac <rw_seq_inc() [clone ._omp_fn.1]+0xec>	2a8: R_X86_64_PC32	.LC1-0x4
    return get_time() - elapsed;
}

double rw_seq_inc(){
    double elapsed = get_time();
    #pragma omp parallel for
 2ac:	31 c0                	xor    eax,eax
 2ae:	48 8d 0c d7          	lea    rcx,[rdi+rdx*8]
 2b2:	31 d2                	xor    edx,edx
 2b4:	48 83 c2 01          	add    rdx,0x1
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        a[i]++;
 2b8:	c5 f5 d4 04 01       	vpaddq ymm0,ymm1,YMMWORD PTR [rcx+rax*1]
 2bd:	c5 fd 7f 04 01       	vmovdqa YMMWORD PTR [rcx+rax*1],ymm0
 2c2:	48 83 c0 20          	add    rax,0x20
 2c6:	49 39 d0             	cmp    r8,rdx
 2c9:	77 e9                	ja     2b4 <rw_seq_inc() [clone ._omp_fn.1]+0xf4>
 2cb:	4c 01 de             	add    rsi,r11
 2ce:	4d 39 da             	cmp    r10,r11
 2d1:	74 3d                	je     310 <rw_seq_inc() [clone ._omp_fn.1]+0x150>
 2d3:	c5 f8 77             	vzeroupper 
 2d6:	48 8d 46 01          	lea    rax,[rsi+0x1]
 2da:	48 83 04 f7 01       	add    QWORD PTR [rdi+rsi*8],0x1
 2df:	49 39 c1             	cmp    r9,rax
 2e2:	76 13                	jbe    2f7 <rw_seq_inc() [clone ._omp_fn.1]+0x137>
 2e4:	48 83 c6 02          	add    rsi,0x2
 2e8:	48 83 04 c7 01       	add    QWORD PTR [rdi+rax*8],0x1
 2ed:	49 39 f1             	cmp    r9,rsi
 2f0:	76 05                	jbe    2f7 <rw_seq_inc() [clone ._omp_fn.1]+0x137>
 2f2:	48 83 04 f7 01       	add    QWORD PTR [rdi+rsi*8],0x1
    return get_time() - elapsed;
}

double rw_seq_inc(){
    double elapsed = get_time();
    #pragma omp parallel for
 2f7:	5b                   	pop    rbx
 2f8:	41 5a                	pop    r10
 2fa:	5d                   	pop    rbp
 2fb:	49 8d 62 f8          	lea    rsp,[r10-0x8]
 2ff:	c3                   	ret    
 300:	48 89 d6             	mov    rsi,rdx
 303:	e9 72 ff ff ff       	jmp    27a <rw_seq_inc() [clone ._omp_fn.1]+0xba>
 308:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
 310:	c5 f8 77             	vzeroupper 
 313:	5b                   	pop    rbx
 314:	41 5a                	pop    r10
 316:	5d                   	pop    rbp
 317:	49 8d 62 f8          	lea    rsp,[r10-0x8]
 31b:	c3                   	ret    
 31c:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]

0000000000000320 <rw_seq_scan() [clone ._omp_fn.2]>:
    return get_time() - elapsed;
}

double rw_seq_scan(){
    double elapsed = get_time();
    #pragma omp parallel for
 320:	53                   	push   rbx
 321:	e8 00 00 00 00       	call   326 <rw_seq_scan() [clone ._omp_fn.2]+0x6>	322: R_X86_64_PC32	omp_get_num_threads-0x4
 326:	48 63 d8             	movsxd rbx,eax
 329:	e8 00 00 00 00       	call   32e <rw_seq_scan() [clone ._omp_fn.2]+0xe>	32a: R_X86_64_PC32	omp_get_thread_num-0x4
 32e:	31 d2                	xor    edx,edx
 330:	48 63 c8             	movsxd rcx,eax
 333:	b8 ff ff ff 03       	mov    eax,0x3ffffff
 338:	48 f7 f3             	div    rbx
 33b:	48 39 d1             	cmp    rcx,rdx
 33e:	73 06                	jae    346 <rw_seq_scan() [clone ._omp_fn.2]+0x26>
 340:	48 83 c0 01          	add    rax,0x1
 344:	31 d2                	xor    edx,edx
 346:	48 0f af c8          	imul   rcx,rax
 34a:	48 01 ca             	add    rdx,rcx
 34d:	48 01 d0             	add    rax,rdx
 350:	48 39 c2             	cmp    rdx,rax
 353:	73 2c                	jae    381 <rw_seq_scan() [clone ._omp_fn.2]+0x61>
 355:	48 8b 3d 00 00 00 00 	mov    rdi,QWORD PTR [rip+0x0]        # 35c <rw_seq_scan() [clone ._omp_fn.2]+0x3c>	358: R_X86_64_PC32	a-0x4
 35c:	48 8d 4a 01          	lea    rcx,[rdx+0x1]
 360:	48 8d 70 01          	lea    rsi,[rax+0x1]
 364:	48 8b 14 d7          	mov    rdx,QWORD PTR [rdi+rdx*8]
 368:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
    for(uint64_t i = 1; i < HS_ARRAY_ELEM; ++i) {
        a[i] += a[i-1];
 370:	48 03 14 cf          	add    rdx,QWORD PTR [rdi+rcx*8]
 374:	48 89 14 cf          	mov    QWORD PTR [rdi+rcx*8],rdx
 378:	48 83 c1 01          	add    rcx,0x1
 37c:	48 39 ce             	cmp    rsi,rcx
 37f:	77 ef                	ja     370 <rw_seq_scan() [clone ._omp_fn.2]+0x50>
    return get_time() - elapsed;
}

double rw_seq_scan(){
    double elapsed = get_time();
    #pragma omp parallel for
 381:	5b                   	pop    rbx
 382:	c3                   	ret    
 383:	0f 1f 00             	nop    DWORD PTR [rax]
 386:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

0000000000000390 <rw_gather() [clone ._omp_fn.3]>:
    return get_time() - elapsed;
}

double rw_gather(){
    double elapsed = get_time();
    #pragma omp parallel for
 390:	53                   	push   rbx
 391:	e8 00 00 00 00       	call   396 <rw_gather() [clone ._omp_fn.3]+0x6>	392: R_X86_64_PC32	omp_get_num_threads-0x4
 396:	48 63 d8             	movsxd rbx,eax
 399:	e8 00 00 00 00       	call   39e <rw_gather() [clone ._omp_fn.3]+0xe>	39a: R_X86_64_PC32	omp_get_thread_num-0x4
 39e:	31 d2                	xor    edx,edx
 3a0:	48 63 c8             	movsxd rcx,eax
 3a3:	b8 ff ff ff 03       	mov    eax,0x3ffffff
 3a8:	48 f7 f3             	div    rbx
 3ab:	48 39 d1             	cmp    rcx,rdx
 3ae:	73 06                	jae    3b6 <rw_gather() [clone ._omp_fn.3]+0x26>
 3b0:	48 83 c0 01          	add    rax,0x1
 3b4:	31 d2                	xor    edx,edx
 3b6:	48 0f af c8          	imul   rcx,rax
 3ba:	48 01 ca             	add    rdx,rcx
 3bd:	48 01 d0             	add    rax,rdx
 3c0:	48 39 c2             	cmp    rdx,rax
 3c3:	73 38                	jae    3fd <rw_gather() [clone ._omp_fn.3]+0x6d>
 3c5:	4c 8b 05 00 00 00 00 	mov    r8,QWORD PTR [rip+0x0]        # 3cc <rw_gather() [clone ._omp_fn.3]+0x3c>	3c8: R_X86_64_PC32	a-0x4
 3cc:	48 8b 3d 00 00 00 00 	mov    rdi,QWORD PTR [rip+0x0]        # 3d3 <rw_gather() [clone ._omp_fn.3]+0x43>	3cf: R_X86_64_PC32	b-0x4
 3d3:	48 83 c2 01          	add    rdx,0x1
 3d7:	48 8b 35 00 00 00 00 	mov    rsi,QWORD PTR [rip+0x0]        # 3de <rw_gather() [clone ._omp_fn.3]+0x4e>	3da: R_X86_64_PC32	idx1-0x4
 3de:	48 83 c0 01          	add    rax,0x1
 3e2:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    for(uint64_t i = 1; i < HS_ARRAY_ELEM; ++i) {
        a[i] = b[idx1[i]];
 3e8:	48 8b 0c d6          	mov    rcx,QWORD PTR [rsi+rdx*8]
 3ec:	48 8b 0c cf          	mov    rcx,QWORD PTR [rdi+rcx*8]
 3f0:	49 89 0c d0          	mov    QWORD PTR [r8+rdx*8],rcx
 3f4:	48 83 c2 01          	add    rdx,0x1
 3f8:	48 39 d0             	cmp    rax,rdx
 3fb:	77 eb                	ja     3e8 <rw_gather() [clone ._omp_fn.3]+0x58>
    return get_time() - elapsed;
}

double rw_gather(){
    double elapsed = get_time();
    #pragma omp parallel for
 3fd:	5b                   	pop    rbx
 3fe:	c3                   	ret    
 3ff:	90                   	nop

0000000000000400 <rw_scatter() [clone ._omp_fn.4]>:
    return get_time() - elapsed;
}

double rw_scatter(){
    double elapsed = get_time();
    #pragma omp parallel for
 400:	53                   	push   rbx
 401:	e8 00 00 00 00       	call   406 <rw_scatter() [clone ._omp_fn.4]+0x6>	402: R_X86_64_PC32	omp_get_num_threads-0x4
 406:	48 63 d8             	movsxd rbx,eax
 409:	e8 00 00 00 00       	call   40e <rw_scatter() [clone ._omp_fn.4]+0xe>	40a: R_X86_64_PC32	omp_get_thread_num-0x4
 40e:	31 d2                	xor    edx,edx
 410:	48 63 c8             	movsxd rcx,eax
 413:	b8 ff ff ff 03       	mov    eax,0x3ffffff
 418:	48 f7 f3             	div    rbx
 41b:	48 39 d1             	cmp    rcx,rdx
 41e:	73 06                	jae    426 <rw_scatter() [clone ._omp_fn.4]+0x26>
 420:	48 83 c0 01          	add    rax,0x1
 424:	31 d2                	xor    edx,edx
 426:	48 0f af c8          	imul   rcx,rax
 42a:	48 01 ca             	add    rdx,rcx
 42d:	48 01 d0             	add    rax,rdx
 430:	48 39 c2             	cmp    rdx,rax
 433:	73 38                	jae    46d <rw_scatter() [clone ._omp_fn.4]+0x6d>
 435:	4c 8b 0d 00 00 00 00 	mov    r9,QWORD PTR [rip+0x0]        # 43c <rw_scatter() [clone ._omp_fn.4]+0x3c>	438: R_X86_64_PC32	a-0x4
 43c:	4c 8b 05 00 00 00 00 	mov    r8,QWORD PTR [rip+0x0]        # 443 <rw_scatter() [clone ._omp_fn.4]+0x43>	43f: R_X86_64_PC32	idx1-0x4
 443:	48 83 c2 01          	add    rdx,0x1
 447:	48 8b 3d 00 00 00 00 	mov    rdi,QWORD PTR [rip+0x0]        # 44e <rw_scatter() [clone ._omp_fn.4]+0x4e>	44a: R_X86_64_PC32	b-0x4
 44e:	48 83 c0 01          	add    rax,0x1
 452:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
    for(uint64_t i = 1; i < HS_ARRAY_ELEM; ++i) {
        a[idx1[i]] = b[i];
 458:	48 8b 34 d7          	mov    rsi,QWORD PTR [rdi+rdx*8]
 45c:	49 8b 0c d0          	mov    rcx,QWORD PTR [r8+rdx*8]
 460:	48 83 c2 01          	add    rdx,0x1
 464:	48 39 d0             	cmp    rax,rdx
 467:	49 89 34 c9          	mov    QWORD PTR [r9+rcx*8],rsi
 46b:	77 eb                	ja     458 <rw_scatter() [clone ._omp_fn.4]+0x58>
    return get_time() - elapsed;
}

double rw_scatter(){
    double elapsed = get_time();
    #pragma omp parallel for
 46d:	5b                   	pop    rbx
 46e:	c3                   	ret    
 46f:	90                   	nop

0000000000000470 <rw_scatter_gather() [clone ._omp_fn.5]>:
    return get_time() - elapsed;
}

double rw_scatter_gather(){
    double elapsed = get_time();
    #pragma omp parallel for
 470:	53                   	push   rbx
 471:	e8 00 00 00 00       	call   476 <rw_scatter_gather() [clone ._omp_fn.5]+0x6>	472: R_X86_64_PC32	omp_get_num_threads-0x4
 476:	48 63 d8             	movsxd rbx,eax
 479:	e8 00 00 00 00       	call   47e <rw_scatter_gather() [clone ._omp_fn.5]+0xe>	47a: R_X86_64_PC32	omp_get_thread_num-0x4
 47e:	31 d2                	xor    edx,edx
 480:	48 63 c8             	movsxd rcx,eax
 483:	b8 ff ff ff 03       	mov    eax,0x3ffffff
 488:	48 f7 f3             	div    rbx
 48b:	48 39 d1             	cmp    rcx,rdx
 48e:	73 06                	jae    496 <rw_scatter_gather() [clone ._omp_fn.5]+0x26>
 490:	48 83 c0 01          	add    rax,0x1
 494:	31 d2                	xor    edx,edx
 496:	48 0f af c8          	imul   rcx,rax
 49a:	48 01 ca             	add    rdx,rcx
 49d:	48 01 d0             	add    rax,rdx
 4a0:	48 39 c2             	cmp    rdx,rax
 4a3:	73 44                	jae    4e9 <rw_scatter_gather() [clone ._omp_fn.5]+0x79>
 4a5:	4c 8b 15 00 00 00 00 	mov    r10,QWORD PTR [rip+0x0]        # 4ac <rw_scatter_gather() [clone ._omp_fn.5]+0x3c>	4a8: R_X86_64_PC32	a-0x4
 4ac:	4c 8b 0d 00 00 00 00 	mov    r9,QWORD PTR [rip+0x0]        # 4b3 <rw_scatter_gather() [clone ._omp_fn.5]+0x43>	4af: R_X86_64_PC32	idx1-0x4
 4b3:	48 83 c2 01          	add    rdx,0x1
 4b7:	4c 8b 05 00 00 00 00 	mov    r8,QWORD PTR [rip+0x0]        # 4be <rw_scatter_gather() [clone ._omp_fn.5]+0x4e>	4ba: R_X86_64_PC32	b-0x4
 4be:	48 8b 3d 00 00 00 00 	mov    rdi,QWORD PTR [rip+0x0]        # 4c5 <rw_scatter_gather() [clone ._omp_fn.5]+0x55>	4c1: R_X86_64_PC32	idx2-0x4
 4c5:	48 83 c0 01          	add    rax,0x1
 4c9:	0f 1f 80 00 00 00 00 	nop    DWORD PTR [rax+0x0]
    for(uint64_t i = 1; i < HS_ARRAY_ELEM; ++i) {
        a[idx1[i]] = b[idx2[i]];
 4d0:	48 8b 0c d7          	mov    rcx,QWORD PTR [rdi+rdx*8]
 4d4:	49 8b 34 c8          	mov    rsi,QWORD PTR [r8+rcx*8]
 4d8:	49 8b 0c d1          	mov    rcx,QWORD PTR [r9+rdx*8]
 4dc:	48 83 c2 01          	add    rdx,0x1
 4e0:	48 39 d0             	cmp    rax,rdx
 4e3:	49 89 34 ca          	mov    QWORD PTR [r10+rcx*8],rsi
 4e7:	77 e7                	ja     4d0 <rw_scatter_gather() [clone ._omp_fn.5]+0x60>
    return get_time() - elapsed;
}

double rw_scatter_gather(){
    double elapsed = get_time();
    #pragma omp parallel for
 4e9:	5b                   	pop    rbx
 4ea:	c3                   	ret    
 4eb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

00000000000004f0 <rw_seq_copy()>:
#include "common.h"
#include <string.h>

double rw_seq_copy(){
 4f0:	48 83 ec 18          	sub    rsp,0x18
    double elapsed = get_time();
 4f4:	e8 00 00 00 00       	call   4f9 <rw_seq_copy()+0x9>	4f5: R_X86_64_PC32	get_time()-0x4
 4f9:	31 c9                	xor    ecx,ecx
 4fb:	31 d2                	xor    edx,edx
 4fd:	31 f6                	xor    esi,esi
 4ff:	bf 00 00 00 00       	mov    edi,0x0	500: R_X86_64_32	.text
 504:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 50a:	e8 00 00 00 00       	call   50f <rw_seq_copy()+0x1f>	50b: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        a[i] = b[i];
    }
    return get_time() - elapsed;
 50f:	e8 00 00 00 00       	call   514 <rw_seq_copy()+0x24>	510: R_X86_64_PC32	get_time()-0x4
 514:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 51a:	48 83 c4 18          	add    rsp,0x18
 51e:	c3                   	ret    
 51f:	90                   	nop

0000000000000520 <rw_seq_inc()>:

double rw_seq_inc(){
 520:	48 83 ec 18          	sub    rsp,0x18
    double elapsed = get_time();
 524:	e8 00 00 00 00       	call   529 <rw_seq_inc()+0x9>	525: R_X86_64_PC32	get_time()-0x4
 529:	31 c9                	xor    ecx,ecx
 52b:	31 d2                	xor    edx,edx
 52d:	31 f6                	xor    esi,esi
 52f:	bf 00 00 00 00       	mov    edi,0x0	530: R_X86_64_32	.text+0x1c0
 534:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 53a:	e8 00 00 00 00       	call   53f <rw_seq_inc()+0x1f>	53b: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        a[i]++;
    }
    return get_time() - elapsed;
 53f:	e8 00 00 00 00       	call   544 <rw_seq_inc()+0x24>	540: R_X86_64_PC32	get_time()-0x4
 544:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 54a:	48 83 c4 18          	add    rsp,0x18
 54e:	c3                   	ret    
 54f:	90                   	nop

0000000000000550 <rw_seq_scan()>:

double rw_seq_scan(){
 550:	48 83 ec 18          	sub    rsp,0x18
    double elapsed = get_time();
 554:	e8 00 00 00 00       	call   559 <rw_seq_scan()+0x9>	555: R_X86_64_PC32	get_time()-0x4
 559:	31 c9                	xor    ecx,ecx
 55b:	31 d2                	xor    edx,edx
 55d:	31 f6                	xor    esi,esi
 55f:	bf 00 00 00 00       	mov    edi,0x0	560: R_X86_64_32	.text+0x320
 564:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 56a:	e8 00 00 00 00       	call   56f <rw_seq_scan()+0x1f>	56b: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 1; i < HS_ARRAY_ELEM; ++i) {
        a[i] += a[i-1];
    }
    return get_time() - elapsed;
 56f:	e8 00 00 00 00       	call   574 <rw_seq_scan()+0x24>	570: R_X86_64_PC32	get_time()-0x4
 574:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 57a:	48 83 c4 18          	add    rsp,0x18
 57e:	c3                   	ret    
 57f:	90                   	nop

0000000000000580 <rw_gather()>:

double rw_gather(){
 580:	48 83 ec 18          	sub    rsp,0x18
    double elapsed = get_time();
 584:	e8 00 00 00 00       	call   589 <rw_gather()+0x9>	585: R_X86_64_PC32	get_time()-0x4
 589:	31 c9                	xor    ecx,ecx
 58b:	31 d2                	xor    edx,edx
 58d:	31 f6                	xor    esi,esi
 58f:	bf 00 00 00 00       	mov    edi,0x0	590: R_X86_64_32	.text+0x390
 594:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 59a:	e8 00 00 00 00       	call   59f <rw_gather()+0x1f>	59b: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 1; i < HS_ARRAY_ELEM; ++i) {
        a[i] = b[idx1[i]];
    }
    return get_time() - elapsed;
 59f:	e8 00 00 00 00       	call   5a4 <rw_gather()+0x24>	5a0: R_X86_64_PC32	get_time()-0x4
 5a4:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 5aa:	48 83 c4 18          	add    rsp,0x18
 5ae:	c3                   	ret    
 5af:	90                   	nop

00000000000005b0 <rw_scatter()>:

double rw_scatter(){
 5b0:	48 83 ec 18          	sub    rsp,0x18
    double elapsed = get_time();
 5b4:	e8 00 00 00 00       	call   5b9 <rw_scatter()+0x9>	5b5: R_X86_64_PC32	get_time()-0x4
 5b9:	31 c9                	xor    ecx,ecx
 5bb:	31 d2                	xor    edx,edx
 5bd:	31 f6                	xor    esi,esi
 5bf:	bf 00 00 00 00       	mov    edi,0x0	5c0: R_X86_64_32	.text+0x400
 5c4:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 5ca:	e8 00 00 00 00       	call   5cf <rw_scatter()+0x1f>	5cb: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 1; i < HS_ARRAY_ELEM; ++i) {
        a[idx1[i]] = b[i];
    }
    return get_time() - elapsed;
 5cf:	e8 00 00 00 00       	call   5d4 <rw_scatter()+0x24>	5d0: R_X86_64_PC32	get_time()-0x4
 5d4:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 5da:	48 83 c4 18          	add    rsp,0x18
 5de:	c3                   	ret    
 5df:	90                   	nop

00000000000005e0 <rw_scatter_gather()>:

double rw_scatter_gather(){
 5e0:	48 83 ec 18          	sub    rsp,0x18
    double elapsed = get_time();
 5e4:	e8 00 00 00 00       	call   5e9 <rw_scatter_gather()+0x9>	5e5: R_X86_64_PC32	get_time()-0x4
 5e9:	31 c9                	xor    ecx,ecx
 5eb:	31 d2                	xor    edx,edx
 5ed:	31 f6                	xor    esi,esi
 5ef:	bf 00 00 00 00       	mov    edi,0x0	5f0: R_X86_64_32	.text+0x470
 5f4:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 5fa:	e8 00 00 00 00       	call   5ff <rw_scatter_gather()+0x1f>	5fb: R_X86_64_PC32	GOMP_parallel-0x4
    #pragma omp parallel for
    for(uint64_t i = 1; i < HS_ARRAY_ELEM; ++i) {
        a[idx1[i]] = b[idx2[i]];
    }
    return get_time() - elapsed;
 5ff:	e8 00 00 00 00       	call   604 <rw_scatter_gather()+0x24>	600: R_X86_64_PC32	get_time()-0x4
 604:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 60a:	48 83 c4 18          	add    rsp,0x18
 60e:	c3                   	ret    
 60f:	90                   	nop

0000000000000610 <rw_tile(unsigned long, unsigned long)>:

double rw_tile(uint64_t L, uint64_t K){
 610:	55                   	push   rbp
 611:	53                   	push   rbx
 612:	48 89 f5             	mov    rbp,rsi
 615:	48 89 fb             	mov    rbx,rdi
 618:	48 83 ec 18          	sub    rsp,0x18
    double elapsed = get_time();
 61c:	e8 00 00 00 00       	call   621 <rw_tile(unsigned long, unsigned long)+0x11>	61d: R_X86_64_PC32	get_time()-0x4
 621:	48 8b 15 00 00 00 00 	mov    rdx,QWORD PTR [rip+0x0]        # 628 <rw_tile(unsigned long, unsigned long)+0x18>	624: R_X86_64_PC32	a-0x4
 628:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 62e:	48 8d 7b ff          	lea    rdi,[rbx-0x1]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
 632:	45 31 c0             	xor    r8d,r8d
 635:	0f 1f 00             	nop    DWORD PTR [rax]
        for(uint64_t j = 0; j < L; j++) {
 638:	48 85 db             	test   rbx,rbx
 63b:	4a 8d 0c 07          	lea    rcx,[rdi+r8*1]
 63f:	4c 89 c0             	mov    rax,r8
 642:	75 18                	jne    65c <rw_tile(unsigned long, unsigned long)+0x4c>
 644:	eb 20                	jmp    666 <rw_tile(unsigned long, unsigned long)+0x56>
 646:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]
            const uint64_t idx = i + j;
 650:	48 83 c0 01          	add    rax,0x1
            if(idx >= HS_ARRAY_ELEM)
 654:	48 3d 00 00 00 04    	cmp    rax,0x4000000
 65a:	74 0a                	je     666 <rw_tile(unsigned long, unsigned long)+0x56>
                break;
            a[idx]++;
 65c:	48 83 04 c2 01       	add    QWORD PTR [rdx+rax*8],0x1
}

double rw_tile(uint64_t L, uint64_t K){
    double elapsed = get_time();
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
 661:	48 39 c1             	cmp    rcx,rax
 664:	75 ea                	jne    650 <rw_tile(unsigned long, unsigned long)+0x40>
    return get_time() - elapsed;
}

double rw_tile(uint64_t L, uint64_t K){
    double elapsed = get_time();
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
 666:	49 01 e8             	add    r8,rbp
 669:	49 81 f8 ff ff ff 03 	cmp    r8,0x3ffffff
 670:	76 c6                	jbe    638 <rw_tile(unsigned long, unsigned long)+0x28>
            if(idx >= HS_ARRAY_ELEM)
                break;
            a[idx]++;
        }
    }
    return get_time() - elapsed;
 672:	e8 00 00 00 00       	call   677 <rw_tile(unsigned long, unsigned long)+0x67>	673: R_X86_64_PC32	get_time()-0x4
 677:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 67d:	48 83 c4 18          	add    rsp,0x18
 681:	5b                   	pop    rbx
 682:	5d                   	pop    rbp
 683:	c3                   	ret    
