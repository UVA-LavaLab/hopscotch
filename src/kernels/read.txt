
read_kernels.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <r_seq_ind() [clone ._omp_fn.0]>:
#include "common.h"

double r_seq_ind(){
    volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
   0:	55                   	push   rbp
   1:	53                   	push   rbx
   2:	48 89 fb             	mov    rbx,rdi
   5:	48 83 ec 08          	sub    rsp,0x8
   9:	e8 00 00 00 00       	call   e <r_seq_ind() [clone ._omp_fn.0]+0xe>	a: R_X86_64_PC32	omp_get_num_threads-0x4
   e:	48 63 e8             	movsxd rbp,eax
  11:	e8 00 00 00 00       	call   16 <r_seq_ind() [clone ._omp_fn.0]+0x16>	12: R_X86_64_PC32	omp_get_thread_num-0x4
  16:	31 d2                	xor    edx,edx
  18:	48 63 c8             	movsxd rcx,eax
  1b:	b8 00 00 00 04       	mov    eax,0x4000000
  20:	48 f7 f5             	div    rbp
  23:	48 39 d1             	cmp    rcx,rdx
  26:	73 06                	jae    2e <r_seq_ind() [clone ._omp_fn.0]+0x2e>
  28:	48 83 c0 01          	add    rax,0x1
  2c:	31 d2                	xor    edx,edx
  2e:	48 0f af c8          	imul   rcx,rax
  32:	48 01 ca             	add    rdx,rcx
  35:	48 01 d0             	add    rax,rdx
  38:	48 39 c2             	cmp    rdx,rax
  3b:	73 1f                	jae    5c <r_seq_ind() [clone ._omp_fn.0]+0x5c>
  3d:	48 8b 0b             	mov    rcx,QWORD PTR [rbx]
  40:	48 8d 14 d1          	lea    rdx,[rcx+rdx*8]
  44:	48 8d 04 c1          	lea    rax,[rcx+rax*8]
  48:	0f 1f 84 00 00 00 00 00 	nop    DWORD PTR [rax+rax*1+0x0]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        volatile data_t res = vol_a[i];
  50:	48 8b 0a             	mov    rcx,QWORD PTR [rdx]
  53:	48 83 c2 08          	add    rdx,0x8
  57:	48 39 d0             	cmp    rax,rdx
  5a:	75 f4                	jne    50 <r_seq_ind() [clone ._omp_fn.0]+0x50>
#include "common.h"

double r_seq_ind(){
    volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
  5c:	48 83 c4 08          	add    rsp,0x8
  60:	5b                   	pop    rbx
  61:	5d                   	pop    rbp
  62:	c3                   	ret    
  63:	0f 1f 00             	nop    DWORD PTR [rax]
  66:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

0000000000000070 <r_seq_reduce() [clone ._omp_fn.1]>:

double r_seq_reduce(){
    volatile data_t * vol_a = a;
    volatile uint64_t sum = 0;
    double elapsed = get_time();
    #pragma omp parallel for simd reduction(+ : sum)
  70:	4c 8d 54 24 08       	lea    r10,[rsp+0x8]
  75:	48 83 e4 e0          	and    rsp,0xffffffffffffffe0
  79:	41 ff 72 f8          	push   QWORD PTR [r10-0x8]
  7d:	55                   	push   rbp
  7e:	48 89 e5             	mov    rbp,rsp
  81:	41 55                	push   r13
  83:	41 54                	push   r12
  85:	41 52                	push   r10
  87:	53                   	push   rbx
  88:	49 89 fc             	mov    r12,rdi
  8b:	45 31 ed             	xor    r13d,r13d
  8e:	48 83 ec 50          	sub    rsp,0x50
  92:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
  9b:	48 89 45 c8          	mov    QWORD PTR [rbp-0x38],rax
  9f:	31 c0                	xor    eax,eax
  a1:	e8 00 00 00 00       	call   a6 <r_seq_reduce() [clone ._omp_fn.1]+0x36>	a2: R_X86_64_PC32	omp_get_num_threads-0x4
  a6:	48 63 d8             	movsxd rbx,eax
  a9:	e8 00 00 00 00       	call   ae <r_seq_reduce() [clone ._omp_fn.1]+0x3e>	aa: R_X86_64_PC32	omp_get_thread_num-0x4
  ae:	31 d2                	xor    edx,edx
  b0:	48 63 c8             	movsxd rcx,eax
  b3:	b8 00 00 00 04       	mov    eax,0x4000000
  b8:	48 f7 f3             	div    rbx
  bb:	48 39 d1             	cmp    rcx,rdx
  be:	73 06                	jae    c6 <r_seq_reduce() [clone ._omp_fn.1]+0x56>
  c0:	48 83 c0 01          	add    rax,0x1
  c4:	31 d2                	xor    edx,edx
  c6:	48 0f af c8          	imul   rcx,rax
  ca:	48 01 ca             	add    rdx,rcx
  cd:	4c 8d 04 10          	lea    r8,[rax+rdx*1]
  d1:	4c 39 c2             	cmp    rdx,r8
  d4:	0f 83 c4 00 00 00    	jae    19e <r_seq_reduce() [clone ._omp_fn.1]+0x12e>
  da:	48 8d 48 fc          	lea    rcx,[rax-0x4]
  de:	48 8d 70 ff          	lea    rsi,[rax-0x1]
  e2:	48 c7 45 90 00 00 00 00 	mov    QWORD PTR [rbp-0x70],0x0
  ea:	48 c7 45 98 00 00 00 00 	mov    QWORD PTR [rbp-0x68],0x0
  f2:	48 c7 45 a0 00 00 00 00 	mov    QWORD PTR [rbp-0x60],0x0
  fa:	48 c1 e9 02          	shr    rcx,0x2
  fe:	48 c7 45 a8 00 00 00 00 	mov    QWORD PTR [rbp-0x58],0x0
 106:	4c 8b 0d 00 00 00 00 	mov    r9,QWORD PTR [rip+0x0]        # 10d <r_seq_reduce() [clone ._omp_fn.1]+0x9d>	109: R_X86_64_PC32	a-0x4
 10d:	48 83 c1 01          	add    rcx,0x1
 111:	48 83 fe 02          	cmp    rsi,0x2
 115:	48 8d 3c 8d 00 00 00 00 	lea    rdi,[rcx*4+0x0]
 11d:	76 38                	jbe    157 <r_seq_reduce() [clone ._omp_fn.1]+0xe7>
 11f:	c5 fd 6f 45 90       	vmovdqa ymm0,YMMWORD PTR [rbp-0x70]
 124:	49 8d 34 d1          	lea    rsi,[r9+rdx*8]
 128:	45 31 d2             	xor    r10d,r10d
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        sum += a[i];
 12b:	c5 fa 6f 0e          	vmovdqu xmm1,XMMWORD PTR [rsi]
 12f:	49 83 c2 01          	add    r10,0x1
 133:	48 83 c6 20          	add    rsi,0x20
 137:	c4 e3 75 38 4e f0 01 	vinserti128 ymm1,ymm1,XMMWORD PTR [rsi-0x10],0x1
 13e:	4c 39 d1             	cmp    rcx,r10
 141:	c5 fd d4 c1          	vpaddq ymm0,ymm0,ymm1
 145:	77 e4                	ja     12b <r_seq_reduce() [clone ._omp_fn.1]+0xbb>
 147:	48 01 fa             	add    rdx,rdi
 14a:	48 39 c7             	cmp    rdi,rax
 14d:	c5 fd 7f 45 90       	vmovdqa YMMWORD PTR [rbp-0x70],ymm0
 152:	74 74                	je     1c8 <r_seq_reduce() [clone ._omp_fn.1]+0x158>
 154:	c5 f8 77             	vzeroupper 
 157:	48 8b 45 90          	mov    rax,QWORD PTR [rbp-0x70]
 15b:	49 03 04 d1          	add    rax,QWORD PTR [r9+rdx*8]
 15f:	48 8d 4a 01          	lea    rcx,[rdx+0x1]
 163:	4c 39 c1             	cmp    rcx,r8
 166:	48 89 45 90          	mov    QWORD PTR [rbp-0x70],rax
 16a:	73 19                	jae    185 <r_seq_reduce() [clone ._omp_fn.1]+0x115>
 16c:	49 03 04 c9          	add    rax,QWORD PTR [r9+rcx*8]
 170:	48 83 c2 02          	add    rdx,0x2
 174:	4c 39 c2             	cmp    rdx,r8
 177:	48 89 45 90          	mov    QWORD PTR [rbp-0x70],rax
 17b:	73 08                	jae    185 <r_seq_reduce() [clone ._omp_fn.1]+0x115>
 17d:	49 03 04 d1          	add    rax,QWORD PTR [r9+rdx*8]
 181:	48 89 45 90          	mov    QWORD PTR [rbp-0x70],rax
double r_seq_reduce(){
    volatile data_t * vol_a = a;
    volatile uint64_t sum = 0;
    double elapsed = get_time();
    #pragma omp parallel for simd reduction(+ : sum)
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
 185:	4c 8b 6d 90          	mov    r13,QWORD PTR [rbp-0x70]
 189:	48 8b 45 98          	mov    rax,QWORD PTR [rbp-0x68]
 18d:	49 01 c5             	add    r13,rax
 190:	48 8b 45 a0          	mov    rax,QWORD PTR [rbp-0x60]
 194:	49 01 c5             	add    r13,rax
 197:	48 8b 45 a8          	mov    rax,QWORD PTR [rbp-0x58]
 19b:	49 01 c5             	add    r13,rax

double r_seq_reduce(){
    volatile data_t * vol_a = a;
    volatile uint64_t sum = 0;
    double elapsed = get_time();
    #pragma omp parallel for simd reduction(+ : sum)
 19e:	f0 4d 01 2c 24       	lock add QWORD PTR [r12],r13
 1a3:	48 8b 45 c8          	mov    rax,QWORD PTR [rbp-0x38]
 1a7:	64 48 33 04 25 28 00 00 00 	xor    rax,QWORD PTR fs:0x28
 1b0:	75 1b                	jne    1cd <r_seq_reduce() [clone ._omp_fn.1]+0x15d>
 1b2:	48 83 c4 50          	add    rsp,0x50
 1b6:	5b                   	pop    rbx
 1b7:	41 5a                	pop    r10
 1b9:	41 5c                	pop    r12
 1bb:	41 5d                	pop    r13
 1bd:	5d                   	pop    rbp
 1be:	49 8d 62 f8          	lea    rsp,[r10-0x8]
 1c2:	c3                   	ret    
 1c3:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
 1c8:	c5 f8 77             	vzeroupper 
 1cb:	eb b8                	jmp    185 <r_seq_reduce() [clone ._omp_fn.1]+0x115>
 1cd:	e8 00 00 00 00       	call   1d2 <r_seq_reduce() [clone ._omp_fn.1]+0x162>	1ce: R_X86_64_PC32	__stack_chk_fail-0x4
 1d2:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
 1d6:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

00000000000001e0 <r_rand_ind() [clone ._omp_fn.2]>:
}

double r_rand_ind(){
    volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 1e0:	55                   	push   rbp
 1e1:	53                   	push   rbx
 1e2:	48 89 fb             	mov    rbx,rdi
 1e5:	48 83 ec 08          	sub    rsp,0x8
 1e9:	e8 00 00 00 00       	call   1ee <r_rand_ind() [clone ._omp_fn.2]+0xe>	1ea: R_X86_64_PC32	omp_get_num_threads-0x4
 1ee:	48 63 e8             	movsxd rbp,eax
 1f1:	e8 00 00 00 00       	call   1f6 <r_rand_ind() [clone ._omp_fn.2]+0x16>	1f2: R_X86_64_PC32	omp_get_thread_num-0x4
 1f6:	31 d2                	xor    edx,edx
 1f8:	48 63 c8             	movsxd rcx,eax
 1fb:	b8 00 00 00 04       	mov    eax,0x4000000
 200:	48 f7 f5             	div    rbp
 203:	48 39 d1             	cmp    rcx,rdx
 206:	73 06                	jae    20e <r_rand_ind() [clone ._omp_fn.2]+0x2e>
 208:	48 83 c0 01          	add    rax,0x1
 20c:	31 d2                	xor    edx,edx
 20e:	48 0f af c8          	imul   rcx,rax
 212:	48 01 ca             	add    rdx,rcx
 215:	48 01 d0             	add    rax,rdx
 218:	48 39 c2             	cmp    rdx,rax
 21b:	73 36                	jae    253 <r_rand_ind() [clone ._omp_fn.2]+0x73>
 21d:	be ef be ad de       	mov    esi,0xdeadbeef
 222:	4c 8b 03             	mov    r8,QWORD PTR [rbx]
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        uint64_t idx = ((i * 0xDEADBEEF) ^ 0xC0FFEE0B) % HS_ARRAY_ELEM;
        volatile data_t res = vol_a[idx];
 225:	bf 0b ee ff c0       	mov    edi,0xc0ffee0b
 22a:	48 0f af d6          	imul   rdx,rsi
 22e:	48 0f af c6          	imul   rax,rsi
 232:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]
 238:	48 89 d1             	mov    rcx,rdx
 23b:	48 01 f2             	add    rdx,rsi
 23e:	48 31 f9             	xor    rcx,rdi
 241:	81 e1 ff ff ff 03    	and    ecx,0x3ffffff
 247:	48 39 d0             	cmp    rax,rdx
 24a:	49 8d 0c c8          	lea    rcx,[r8+rcx*8]
 24e:	48 8b 09             	mov    rcx,QWORD PTR [rcx]
 251:	75 e5                	jne    238 <r_rand_ind() [clone ._omp_fn.2]+0x58>
}

double r_rand_ind(){
    volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 253:	48 83 c4 08          	add    rsp,0x8
 257:	5b                   	pop    rbx
 258:	5d                   	pop    rbp
 259:	c3                   	ret    
 25a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000000260 <r_stride_2() [clone ._omp_fn.3]>:
}

double r_stride_2(){
    volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 260:	55                   	push   rbp
 261:	53                   	push   rbx
 262:	48 89 fb             	mov    rbx,rdi
 265:	48 83 ec 08          	sub    rsp,0x8
 269:	e8 00 00 00 00       	call   26e <r_stride_2() [clone ._omp_fn.3]+0xe>	26a: R_X86_64_PC32	omp_get_num_threads-0x4
 26e:	48 63 e8             	movsxd rbp,eax
 271:	e8 00 00 00 00       	call   276 <r_stride_2() [clone ._omp_fn.3]+0x16>	272: R_X86_64_PC32	omp_get_thread_num-0x4
 276:	31 d2                	xor    edx,edx
 278:	48 63 c8             	movsxd rcx,eax
 27b:	b8 00 00 00 02       	mov    eax,0x2000000
 280:	48 f7 f5             	div    rbp
 283:	48 39 d1             	cmp    rcx,rdx
 286:	73 06                	jae    28e <r_stride_2() [clone ._omp_fn.3]+0x2e>
 288:	48 83 c0 01          	add    rax,0x1
 28c:	31 d2                	xor    edx,edx
 28e:	48 0f af c8          	imul   rcx,rax
 292:	48 01 ca             	add    rdx,rcx
 295:	48 01 d0             	add    rax,rdx
 298:	48 39 c2             	cmp    rdx,rax
 29b:	73 23                	jae    2c0 <r_stride_2() [clone ._omp_fn.3]+0x60>
 29d:	48 8d 0c 12          	lea    rcx,[rdx+rdx*1]
 2a1:	48 c1 e2 04          	shl    rdx,0x4
 2a5:	48 03 13             	add    rdx,QWORD PTR [rbx]
 2a8:	48 01 c0             	add    rax,rax
 2ab:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
 2b0:	48 83 c1 02          	add    rcx,0x2
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 2) {
        volatile register data_t res = vol_a[i];
 2b4:	48 8b 32             	mov    rsi,QWORD PTR [rdx]
 2b7:	48 83 c2 10          	add    rdx,0x10
 2bb:	48 39 c8             	cmp    rax,rcx
 2be:	77 f0                	ja     2b0 <r_stride_2() [clone ._omp_fn.3]+0x50>
}

double r_stride_2(){
    volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 2c0:	48 83 c4 08          	add    rsp,0x8
 2c4:	5b                   	pop    rbx
 2c5:	5d                   	pop    rbp
 2c6:	c3                   	ret    
 2c7:	66 0f 1f 84 00 00 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]

00000000000002d0 <r_stride_4() [clone ._omp_fn.4]>:
}

double r_stride_4(){
    volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 2d0:	55                   	push   rbp
 2d1:	53                   	push   rbx
 2d2:	48 89 fb             	mov    rbx,rdi
 2d5:	48 83 ec 08          	sub    rsp,0x8
 2d9:	e8 00 00 00 00       	call   2de <r_stride_4() [clone ._omp_fn.4]+0xe>	2da: R_X86_64_PC32	omp_get_num_threads-0x4
 2de:	48 63 e8             	movsxd rbp,eax
 2e1:	e8 00 00 00 00       	call   2e6 <r_stride_4() [clone ._omp_fn.4]+0x16>	2e2: R_X86_64_PC32	omp_get_thread_num-0x4
 2e6:	31 d2                	xor    edx,edx
 2e8:	48 63 c8             	movsxd rcx,eax
 2eb:	b8 00 00 00 01       	mov    eax,0x1000000
 2f0:	48 f7 f5             	div    rbp
 2f3:	48 39 d1             	cmp    rcx,rdx
 2f6:	73 06                	jae    2fe <r_stride_4() [clone ._omp_fn.4]+0x2e>
 2f8:	48 83 c0 01          	add    rax,0x1
 2fc:	31 d2                	xor    edx,edx
 2fe:	48 0f af c8          	imul   rcx,rax
 302:	48 01 ca             	add    rdx,rcx
 305:	48 01 d0             	add    rax,rdx
 308:	48 39 c2             	cmp    rdx,rax
 30b:	73 23                	jae    330 <r_stride_4() [clone ._omp_fn.4]+0x60>
 30d:	48 8d 0c 95 00 00 00 00 	lea    rcx,[rdx*4+0x0]
 315:	48 c1 e2 05          	shl    rdx,0x5
 319:	48 03 13             	add    rdx,QWORD PTR [rbx]
 31c:	48 c1 e0 02          	shl    rax,0x2
 320:	48 83 c1 04          	add    rcx,0x4
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 4) {
        volatile register data_t res = vol_a[i];
 324:	48 8b 32             	mov    rsi,QWORD PTR [rdx]
 327:	48 83 c2 20          	add    rdx,0x20
 32b:	48 39 c8             	cmp    rax,rcx
 32e:	77 f0                	ja     320 <r_stride_4() [clone ._omp_fn.4]+0x50>
}

double r_stride_4(){
    volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 330:	48 83 c4 08          	add    rsp,0x8
 334:	5b                   	pop    rbx
 335:	5d                   	pop    rbp
 336:	c3                   	ret    
 337:	66 0f 1f 84 00 00 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]

0000000000000340 <r_stride_8() [clone ._omp_fn.5]>:
}

double r_stride_8(){
    volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 340:	55                   	push   rbp
 341:	53                   	push   rbx
 342:	48 89 fb             	mov    rbx,rdi
 345:	48 83 ec 08          	sub    rsp,0x8
 349:	e8 00 00 00 00       	call   34e <r_stride_8() [clone ._omp_fn.5]+0xe>	34a: R_X86_64_PC32	omp_get_num_threads-0x4
 34e:	48 63 e8             	movsxd rbp,eax
 351:	e8 00 00 00 00       	call   356 <r_stride_8() [clone ._omp_fn.5]+0x16>	352: R_X86_64_PC32	omp_get_thread_num-0x4
 356:	31 d2                	xor    edx,edx
 358:	48 63 c8             	movsxd rcx,eax
 35b:	b8 00 00 80 00       	mov    eax,0x800000
 360:	48 f7 f5             	div    rbp
 363:	48 39 d1             	cmp    rcx,rdx
 366:	73 06                	jae    36e <r_stride_8() [clone ._omp_fn.5]+0x2e>
 368:	48 83 c0 01          	add    rax,0x1
 36c:	31 d2                	xor    edx,edx
 36e:	48 0f af c8          	imul   rcx,rax
 372:	48 01 ca             	add    rdx,rcx
 375:	48 01 d0             	add    rax,rdx
 378:	48 39 c2             	cmp    rdx,rax
 37b:	73 23                	jae    3a0 <r_stride_8() [clone ._omp_fn.5]+0x60>
 37d:	48 8d 0c d5 00 00 00 00 	lea    rcx,[rdx*8+0x0]
 385:	48 c1 e2 06          	shl    rdx,0x6
 389:	48 03 13             	add    rdx,QWORD PTR [rbx]
 38c:	48 c1 e0 03          	shl    rax,0x3
 390:	48 83 c1 08          	add    rcx,0x8
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 8) {
        volatile register data_t res = vol_a[i];
 394:	48 8b 32             	mov    rsi,QWORD PTR [rdx]
 397:	48 83 c2 40          	add    rdx,0x40
 39b:	48 39 c8             	cmp    rax,rcx
 39e:	77 f0                	ja     390 <r_stride_8() [clone ._omp_fn.5]+0x50>
}

double r_stride_8(){
    volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 3a0:	48 83 c4 08          	add    rsp,0x8
 3a4:	5b                   	pop    rbx
 3a5:	5d                   	pop    rbp
 3a6:	c3                   	ret    
 3a7:	66 0f 1f 84 00 00 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]

00000000000003b0 <r_stride_16() [clone ._omp_fn.6]>:
}

double r_stride_16(){
    volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 3b0:	55                   	push   rbp
 3b1:	53                   	push   rbx
 3b2:	48 89 fb             	mov    rbx,rdi
 3b5:	48 83 ec 08          	sub    rsp,0x8
 3b9:	e8 00 00 00 00       	call   3be <r_stride_16() [clone ._omp_fn.6]+0xe>	3ba: R_X86_64_PC32	omp_get_num_threads-0x4
 3be:	48 63 e8             	movsxd rbp,eax
 3c1:	e8 00 00 00 00       	call   3c6 <r_stride_16() [clone ._omp_fn.6]+0x16>	3c2: R_X86_64_PC32	omp_get_thread_num-0x4
 3c6:	31 d2                	xor    edx,edx
 3c8:	48 63 c8             	movsxd rcx,eax
 3cb:	b8 00 00 40 00       	mov    eax,0x400000
 3d0:	48 f7 f5             	div    rbp
 3d3:	48 39 d1             	cmp    rcx,rdx
 3d6:	73 06                	jae    3de <r_stride_16() [clone ._omp_fn.6]+0x2e>
 3d8:	48 83 c0 01          	add    rax,0x1
 3dc:	31 d2                	xor    edx,edx
 3de:	48 0f af c8          	imul   rcx,rax
 3e2:	48 01 ca             	add    rdx,rcx
 3e5:	48 01 d0             	add    rax,rdx
 3e8:	48 39 c2             	cmp    rdx,rax
 3eb:	73 23                	jae    410 <r_stride_16() [clone ._omp_fn.6]+0x60>
 3ed:	48 89 d1             	mov    rcx,rdx
 3f0:	48 c1 e2 07          	shl    rdx,0x7
 3f4:	48 03 13             	add    rdx,QWORD PTR [rbx]
 3f7:	48 c1 e1 04          	shl    rcx,0x4
 3fb:	48 c1 e0 04          	shl    rax,0x4
 3ff:	90                   	nop
 400:	48 83 c1 10          	add    rcx,0x10
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 16) {
        volatile register data_t res = vol_a[i];
 404:	48 8b 32             	mov    rsi,QWORD PTR [rdx]
 407:	48 83 ea 80          	sub    rdx,0xffffffffffffff80
 40b:	48 39 c8             	cmp    rax,rcx
 40e:	77 f0                	ja     400 <r_stride_16() [clone ._omp_fn.6]+0x50>
}

double r_stride_16(){
    volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 410:	48 83 c4 08          	add    rsp,0x8
 414:	5b                   	pop    rbx
 415:	5d                   	pop    rbp
 416:	c3                   	ret    
 417:	66 0f 1f 84 00 00 00 00 00 	nop    WORD PTR [rax+rax*1+0x0]

0000000000000420 <r_stride_32() [clone ._omp_fn.7]>:
}

double r_stride_32(){
    volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 420:	55                   	push   rbp
 421:	53                   	push   rbx
 422:	48 89 fb             	mov    rbx,rdi
 425:	48 83 ec 08          	sub    rsp,0x8
 429:	e8 00 00 00 00       	call   42e <r_stride_32() [clone ._omp_fn.7]+0xe>	42a: R_X86_64_PC32	omp_get_num_threads-0x4
 42e:	48 63 e8             	movsxd rbp,eax
 431:	e8 00 00 00 00       	call   436 <r_stride_32() [clone ._omp_fn.7]+0x16>	432: R_X86_64_PC32	omp_get_thread_num-0x4
 436:	31 d2                	xor    edx,edx
 438:	48 63 c8             	movsxd rcx,eax
 43b:	b8 00 00 20 00       	mov    eax,0x200000
 440:	48 f7 f5             	div    rbp
 443:	48 39 d1             	cmp    rcx,rdx
 446:	73 06                	jae    44e <r_stride_32() [clone ._omp_fn.7]+0x2e>
 448:	48 83 c0 01          	add    rax,0x1
 44c:	31 d2                	xor    edx,edx
 44e:	48 0f af c8          	imul   rcx,rax
 452:	48 01 ca             	add    rdx,rcx
 455:	48 01 d0             	add    rax,rdx
 458:	48 39 c2             	cmp    rdx,rax
 45b:	73 26                	jae    483 <r_stride_32() [clone ._omp_fn.7]+0x63>
 45d:	48 89 d1             	mov    rcx,rdx
 460:	48 c1 e2 08          	shl    rdx,0x8
 464:	48 03 13             	add    rdx,QWORD PTR [rbx]
 467:	48 c1 e1 05          	shl    rcx,0x5
 46b:	48 c1 e0 05          	shl    rax,0x5
 46f:	90                   	nop
 470:	48 83 c1 20          	add    rcx,0x20
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 32) {
        volatile register data_t res = vol_a[i];
 474:	48 8b 32             	mov    rsi,QWORD PTR [rdx]
 477:	48 81 c2 00 01 00 00 	add    rdx,0x100
 47e:	48 39 c8             	cmp    rax,rcx
 481:	77 ed                	ja     470 <r_stride_32() [clone ._omp_fn.7]+0x50>
}

double r_stride_32(){
    volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 483:	48 83 c4 08          	add    rsp,0x8
 487:	5b                   	pop    rbx
 488:	5d                   	pop    rbp
 489:	c3                   	ret    
 48a:	66 0f 1f 44 00 00    	nop    WORD PTR [rax+rax*1+0x0]

0000000000000490 <r_tile(unsigned long, unsigned long) [clone ._omp_fn.8]>:

double r_tile(uint64_t L, uint64_t K){
//double r_tile(){
    volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 490:	41 54                	push   r12
 492:	55                   	push   rbp
 493:	48 89 fd             	mov    rbp,rdi
 496:	53                   	push   rbx
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
 497:	48 8b 5f 08          	mov    rbx,QWORD PTR [rdi+0x8]
 49b:	e8 00 00 00 00       	call   4a0 <r_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x10>	49c: R_X86_64_PC32	omp_get_num_threads-0x4
 4a0:	4c 63 e0             	movsxd r12,eax
 4a3:	e8 00 00 00 00       	call   4a8 <r_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x18>	4a4: R_X86_64_PC32	omp_get_thread_num-0x4
 4a8:	48 63 f0             	movsxd rsi,eax
 4ab:	48 8d 83 ff ff ff 03 	lea    rax,[rbx+0x3ffffff]
 4b2:	31 d2                	xor    edx,edx
 4b4:	48 f7 f3             	div    rbx
 4b7:	31 d2                	xor    edx,edx
 4b9:	49 f7 f4             	div    r12
 4bc:	48 39 d6             	cmp    rsi,rdx
 4bf:	73 06                	jae    4c7 <r_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x37>
 4c1:	48 83 c0 01          	add    rax,0x1
 4c5:	31 d2                	xor    edx,edx
 4c7:	48 0f af f0          	imul   rsi,rax
 4cb:	48 01 d6             	add    rsi,rdx
 4ce:	4c 8d 0c 30          	lea    r9,[rax+rsi*1]
 4d2:	4c 39 ce             	cmp    rsi,r9
 4d5:	73 58                	jae    52f <r_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x9f>
 4d7:	48 0f af f3          	imul   rsi,rbx
 4db:	48 8b 7d 00          	mov    rdi,QWORD PTR [rbp+0x0]
 4df:	4c 8d 14 dd 00 00 00 00 	lea    r10,[rbx*8+0x0]
 4e7:	4c 0f af cb          	imul   r9,rbx
 4eb:	4c 8d 1c fd 00 00 00 00 	lea    r11,[rdi*8+0x0]
 4f3:	4c 8d 04 f5 00 00 00 00 	lea    r8,[rsi*8+0x0]
 4fb:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        for(uint64_t j = 0; j < L; j++) {
 500:	48 85 ff             	test   rdi,rdi
 503:	74 1f                	je     524 <r_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x94>
 505:	48 8b 4d 10          	mov    rcx,QWORD PTR [rbp+0x10]
 509:	4b 8d 14 03          	lea    rdx,[r11+r8*1]
 50d:	4a 8d 04 01          	lea    rax,[rcx+r8*1]
 511:	48 01 ca             	add    rdx,rcx
 514:	0f 1f 40 00          	nop    DWORD PTR [rax+0x0]
            volatile data_t res = vol_a[i+j];
 518:	48 8b 08             	mov    rcx,QWORD PTR [rax]
 51b:	48 83 c0 08          	add    rax,0x8
//double r_tile(){
    volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
 51f:	48 39 d0             	cmp    rax,rdx
 522:	75 f4                	jne    518 <r_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x88>
 524:	48 01 de             	add    rsi,rbx
 527:	4d 01 d0             	add    r8,r10
 52a:	49 39 f1             	cmp    r9,rsi
 52d:	77 d1                	ja     500 <r_tile(unsigned long, unsigned long) [clone ._omp_fn.8]+0x70>

double r_tile(uint64_t L, uint64_t K){
//double r_tile(){
    volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 52f:	5b                   	pop    rbx
 530:	5d                   	pop    rbp
 531:	41 5c                	pop    r12
 533:	c3                   	ret    
 534:	66 90                	xchg   ax,ax
 536:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

0000000000000540 <r_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]>:
}

double r_dma(data_t** addr, uint64_t* len, uint64_t count) {
    volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 540:	41 54                	push   r12
 542:	55                   	push   rbp
 543:	53                   	push   rbx
    for(uint64_t i = 0; i < count; i++) {
 544:	48 8b 5f 10          	mov    rbx,QWORD PTR [rdi+0x10]
 548:	48 85 db             	test   rbx,rbx
 54b:	74 6c                	je     5b9 <r_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x79>
 54d:	48 89 fd             	mov    rbp,rdi
 550:	e8 00 00 00 00       	call   555 <r_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x15>	551: R_X86_64_PC32	omp_get_num_threads-0x4
 555:	4c 63 e0             	movsxd r12,eax
 558:	e8 00 00 00 00       	call   55d <r_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x1d>	559: R_X86_64_PC32	omp_get_thread_num-0x4
 55d:	31 d2                	xor    edx,edx
 55f:	4c 63 c0             	movsxd r8,eax
 562:	48 89 d8             	mov    rax,rbx
 565:	49 f7 f4             	div    r12
 568:	49 39 d0             	cmp    r8,rdx
 56b:	73 06                	jae    573 <r_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x33>
 56d:	48 83 c0 01          	add    rax,0x1
 571:	31 d2                	xor    edx,edx
 573:	4c 0f af c0          	imul   r8,rax
 577:	49 01 d0             	add    r8,rdx
 57a:	4e 8d 0c 00          	lea    r9,[rax+r8*1]
 57e:	4d 39 c8             	cmp    r8,r9
 581:	73 36                	jae    5b9 <r_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x79>
 583:	4c 8b 55 08          	mov    r10,QWORD PTR [rbp+0x8]
 587:	48 8b 7d 00          	mov    rdi,QWORD PTR [rbp+0x0]
 58b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]
        const uint64_t c_len = len[i];
 590:	4b 8b 0c c2          	mov    rcx,QWORD PTR [r10+r8*8]
        volatile const data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
 594:	31 c0                	xor    eax,eax
    volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < count; i++) {
        const uint64_t c_len = len[i];
        volatile const data_t* c_addr = addr[i];
 596:	4a 8b 14 c7          	mov    rdx,QWORD PTR [rdi+r8*8]
        for(uint64_t j = 0; j < c_len; j++) {
 59a:	48 85 c9             	test   rcx,rcx
 59d:	74 11                	je     5b0 <r_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x70>
 59f:	90                   	nop
 5a0:	48 83 c0 01          	add    rax,0x1
            volatile data_t res = *c_addr++;
 5a4:	48 8b 32             	mov    rsi,QWORD PTR [rdx]
 5a7:	48 83 c2 08          	add    rdx,0x8
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < count; i++) {
        const uint64_t c_len = len[i];
        volatile const data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
 5ab:	48 39 c1             	cmp    rcx,rax
 5ae:	75 f0                	jne    5a0 <r_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x60>
 5b0:	49 83 c0 01          	add    r8,0x1
 5b4:	4d 39 c1             	cmp    r9,r8
 5b7:	75 d7                	jne    590 <r_dma(unsigned long**, unsigned long*, unsigned long) [clone ._omp_fn.9]+0x50>
}

double r_dma(data_t** addr, uint64_t* len, uint64_t count) {
    volatile data_t * vol_a = a;
    double elapsed = get_time();
    #pragma omp parallel for
 5b9:	5b                   	pop    rbx
 5ba:	5d                   	pop    rbp
 5bb:	41 5c                	pop    r12
 5bd:	c3                   	ret    
 5be:	66 90                	xchg   ax,ax

00000000000005c0 <r_seq_ind()>:
#include "common.h"

double r_seq_ind(){
 5c0:	53                   	push   rbx
 5c1:	48 83 ec 20          	sub    rsp,0x20
    volatile data_t * vol_a = a;
 5c5:	48 8b 1d 00 00 00 00 	mov    rbx,QWORD PTR [rip+0x0]        # 5cc <r_seq_ind()+0xc>	5c8: R_X86_64_PC32	a-0x4
#include "common.h"

double r_seq_ind(){
 5cc:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 5d5:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
 5da:	31 c0                	xor    eax,eax
    volatile data_t * vol_a = a;
    double elapsed = get_time();
 5dc:	e8 00 00 00 00       	call   5e1 <r_seq_ind()+0x21>	5dd: R_X86_64_PC32	get_time()-0x4
 5e1:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
 5e6:	31 c9                	xor    ecx,ecx
 5e8:	31 d2                	xor    edx,edx
 5ea:	bf 00 00 00 00       	mov    edi,0x0	5eb: R_X86_64_32	.text
 5ef:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
    #pragma omp parallel for
 5f5:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
 5fa:	e8 00 00 00 00       	call   5ff <r_seq_ind()+0x3f>	5fb: R_X86_64_PC32	GOMP_parallel-0x4
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        volatile data_t res = vol_a[i];
    }
    return get_time() - elapsed;
 5ff:	e8 00 00 00 00       	call   604 <r_seq_ind()+0x44>	600: R_X86_64_PC32	get_time()-0x4
}
 604:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
 609:	64 48 33 04 25 28 00 00 00 	xor    rax,QWORD PTR fs:0x28
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        volatile data_t res = vol_a[i];
    }
    return get_time() - elapsed;
 612:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 618:	75 06                	jne    620 <r_seq_ind()+0x60>
 61a:	48 83 c4 20          	add    rsp,0x20
 61e:	5b                   	pop    rbx
 61f:	c3                   	ret    
 620:	e8 00 00 00 00       	call   625 <r_seq_ind()+0x65>	621: R_X86_64_PC32	__stack_chk_fail-0x4
 625:	90                   	nop
 626:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

0000000000000630 <r_seq_reduce()>:

double r_seq_reduce(){
 630:	48 83 ec 38          	sub    rsp,0x38
 634:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 63d:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
 642:	31 c0                	xor    eax,eax
    volatile data_t * vol_a = a;
    volatile uint64_t sum = 0;
 644:	48 c7 44 24 20 00 00 00 00 	mov    QWORD PTR [rsp+0x20],0x0
    double elapsed = get_time();
 64d:	e8 00 00 00 00       	call   652 <r_seq_reduce()+0x22>	64e: R_X86_64_PC32	get_time()-0x4
    #pragma omp parallel for simd reduction(+ : sum)
 652:	48 8b 44 24 20       	mov    rax,QWORD PTR [rsp+0x20]
 657:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
 65c:	31 c9                	xor    ecx,ecx
 65e:	31 d2                	xor    edx,edx
 660:	bf 00 00 00 00       	mov    edi,0x0	661: R_X86_64_32	.text+0x70
}

double r_seq_reduce(){
    volatile data_t * vol_a = a;
    volatile uint64_t sum = 0;
    double elapsed = get_time();
 665:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
    #pragma omp parallel for simd reduction(+ : sum)
 66b:	48 89 44 24 10       	mov    QWORD PTR [rsp+0x10],rax
 670:	e8 00 00 00 00       	call   675 <r_seq_reduce()+0x45>	671: R_X86_64_PC32	GOMP_parallel-0x4
 675:	48 8b 44 24 10       	mov    rax,QWORD PTR [rsp+0x10]
 67a:	48 89 44 24 20       	mov    QWORD PTR [rsp+0x20],rax
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        sum += a[i];
    }
    return get_time() - elapsed;
 67f:	e8 00 00 00 00       	call   684 <r_seq_reduce()+0x54>	680: R_X86_64_PC32	get_time()-0x4
}
 684:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
 689:	64 48 33 04 25 28 00 00 00 	xor    rax,QWORD PTR fs:0x28
    double elapsed = get_time();
    #pragma omp parallel for simd reduction(+ : sum)
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        sum += a[i];
    }
    return get_time() - elapsed;
 692:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 698:	75 05                	jne    69f <r_seq_reduce()+0x6f>
 69a:	48 83 c4 38          	add    rsp,0x38
 69e:	c3                   	ret    
 69f:	e8 00 00 00 00       	call   6a4 <r_seq_reduce()+0x74>	6a0: R_X86_64_PC32	__stack_chk_fail-0x4
 6a4:	66 90                	xchg   ax,ax
 6a6:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

00000000000006b0 <r_rand_pchase()>:

double r_rand_pchase(){
 6b0:	55                   	push   rbp
 6b1:	53                   	push   rbx
 6b2:	48 83 ec 18          	sub    rsp,0x18
    void **curr = ptr;
 6b6:	48 8b 1d 00 00 00 00 	mov    rbx,QWORD PTR [rip+0x0]        # 6bd <r_rand_pchase()+0xd>	6b9: R_X86_64_PC32	ptr-0x4
    void* saved_val = *ptr;
 6bd:	48 8b 2b             	mov    rbp,QWORD PTR [rbx]
    double elapsed = get_time();
 6c0:	e8 00 00 00 00       	call   6c5 <r_rand_pchase()+0x15>	6c1: R_X86_64_PC32	get_time()-0x4
 6c5:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
 6cb:	b8 00 00 80 00       	mov    eax,0x800000
#if HS_ARRAY_ELEM < ELEM_MIN
    for(uint64_t k = ELEM_MIN / HS_ARRAY_ELEM; k > 0 ; --k) {
#endif
    for(uint64_t i = HS_ARRAY_ELEM; i > 0; i -= 8) {
        //manual loop unroll
        curr = (void**)*curr;
 6d0:	48 8b 13             	mov    rdx,QWORD PTR [rbx]
    void* saved_val = *ptr;
    double elapsed = get_time();
#if HS_ARRAY_ELEM < ELEM_MIN
    for(uint64_t k = ELEM_MIN / HS_ARRAY_ELEM; k > 0 ; --k) {
#endif
    for(uint64_t i = HS_ARRAY_ELEM; i > 0; i -= 8) {
 6d3:	48 83 e8 01          	sub    rax,0x1
        //manual loop unroll
        curr = (void**)*curr;
        curr = (void**)*curr;
 6d7:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
        curr = (void**)*curr;
 6da:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
        curr = (void**)*curr;
 6dd:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
        curr = (void**)*curr;
 6e0:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
        curr = (void**)*curr;
 6e3:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
        curr = (void**)*curr;
 6e6:	48 8b 12             	mov    rdx,QWORD PTR [rdx]
        curr = (void**)*curr;
 6e9:	48 8b 1a             	mov    rbx,QWORD PTR [rdx]
    void* saved_val = *ptr;
    double elapsed = get_time();
#if HS_ARRAY_ELEM < ELEM_MIN
    for(uint64_t k = ELEM_MIN / HS_ARRAY_ELEM; k > 0 ; --k) {
#endif
    for(uint64_t i = HS_ARRAY_ELEM; i > 0; i -= 8) {
 6ec:	75 e2                	jne    6d0 <r_rand_pchase()+0x20>
        curr = (void**)*curr;
    }
#if HS_ARRAY_ELEM < ELEM_MIN
    }
#endif
    elapsed = get_time() - elapsed;
 6ee:	e8 00 00 00 00       	call   6f3 <r_rand_pchase()+0x43>	6ef: R_X86_64_PC32	get_time()-0x4
    *curr = saved_val; //do a write to prevent optimization
 6f3:	48 89 2b             	mov    QWORD PTR [rbx],rbp
    return elapsed;
 6f6:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 6fc:	48 83 c4 18          	add    rsp,0x18
 700:	5b                   	pop    rbx
 701:	5d                   	pop    rbp
 702:	c3                   	ret    
 703:	0f 1f 00             	nop    DWORD PTR [rax]
 706:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

0000000000000710 <r_rand_ind()>:

double r_rand_ind(){
 710:	53                   	push   rbx
 711:	48 83 ec 20          	sub    rsp,0x20
    volatile data_t * vol_a = a;
 715:	48 8b 1d 00 00 00 00 	mov    rbx,QWORD PTR [rip+0x0]        # 71c <r_rand_ind()+0xc>	718: R_X86_64_PC32	a-0x4
    elapsed = get_time() - elapsed;
    *curr = saved_val; //do a write to prevent optimization
    return elapsed;
}

double r_rand_ind(){
 71c:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 725:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
 72a:	31 c0                	xor    eax,eax
    volatile data_t * vol_a = a;
    double elapsed = get_time();
 72c:	e8 00 00 00 00       	call   731 <r_rand_ind()+0x21>	72d: R_X86_64_PC32	get_time()-0x4
 731:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
 736:	31 c9                	xor    ecx,ecx
 738:	31 d2                	xor    edx,edx
 73a:	bf 00 00 00 00       	mov    edi,0x0	73b: R_X86_64_32	.text+0x1e0
 73f:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
    #pragma omp parallel for
 745:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
 74a:	e8 00 00 00 00       	call   74f <r_rand_ind()+0x3f>	74b: R_X86_64_PC32	GOMP_parallel-0x4
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        uint64_t idx = ((i * 0xDEADBEEF) ^ 0xC0FFEE0B) % HS_ARRAY_ELEM;
        volatile data_t res = vol_a[idx];
    }
    return get_time() - elapsed;
 74f:	e8 00 00 00 00       	call   754 <r_rand_ind()+0x44>	750: R_X86_64_PC32	get_time()-0x4
}
 754:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
 759:	64 48 33 04 25 28 00 00 00 	xor    rax,QWORD PTR fs:0x28
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; ++i) {
        uint64_t idx = ((i * 0xDEADBEEF) ^ 0xC0FFEE0B) % HS_ARRAY_ELEM;
        volatile data_t res = vol_a[idx];
    }
    return get_time() - elapsed;
 762:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 768:	75 06                	jne    770 <r_rand_ind()+0x60>
 76a:	48 83 c4 20          	add    rsp,0x20
 76e:	5b                   	pop    rbx
 76f:	c3                   	ret    
 770:	e8 00 00 00 00       	call   775 <r_rand_ind()+0x65>	771: R_X86_64_PC32	__stack_chk_fail-0x4
 775:	90                   	nop
 776:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

0000000000000780 <r_stride_2()>:

double r_stride_2(){
 780:	53                   	push   rbx
 781:	48 83 ec 20          	sub    rsp,0x20
    volatile data_t * vol_a = a;
 785:	48 8b 1d 00 00 00 00 	mov    rbx,QWORD PTR [rip+0x0]        # 78c <r_stride_2()+0xc>	788: R_X86_64_PC32	a-0x4
        volatile data_t res = vol_a[idx];
    }
    return get_time() - elapsed;
}

double r_stride_2(){
 78c:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 795:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
 79a:	31 c0                	xor    eax,eax
    volatile data_t * vol_a = a;
    double elapsed = get_time();
 79c:	e8 00 00 00 00       	call   7a1 <r_stride_2()+0x21>	79d: R_X86_64_PC32	get_time()-0x4
 7a1:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
 7a6:	31 c9                	xor    ecx,ecx
 7a8:	31 d2                	xor    edx,edx
 7aa:	bf 00 00 00 00       	mov    edi,0x0	7ab: R_X86_64_32	.text+0x260
 7af:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
    #pragma omp parallel for
 7b5:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
 7ba:	e8 00 00 00 00       	call   7bf <r_stride_2()+0x3f>	7bb: R_X86_64_PC32	GOMP_parallel-0x4
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 2) {
        volatile register data_t res = vol_a[i];
    }
    return get_time() - elapsed;
 7bf:	e8 00 00 00 00       	call   7c4 <r_stride_2()+0x44>	7c0: R_X86_64_PC32	get_time()-0x4
}
 7c4:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
 7c9:	64 48 33 04 25 28 00 00 00 	xor    rax,QWORD PTR fs:0x28
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 2) {
        volatile register data_t res = vol_a[i];
    }
    return get_time() - elapsed;
 7d2:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 7d8:	75 06                	jne    7e0 <r_stride_2()+0x60>
 7da:	48 83 c4 20          	add    rsp,0x20
 7de:	5b                   	pop    rbx
 7df:	c3                   	ret    
 7e0:	e8 00 00 00 00       	call   7e5 <r_stride_2()+0x65>	7e1: R_X86_64_PC32	__stack_chk_fail-0x4
 7e5:	90                   	nop
 7e6:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

00000000000007f0 <r_stride_4()>:

double r_stride_4(){
 7f0:	53                   	push   rbx
 7f1:	48 83 ec 20          	sub    rsp,0x20
    volatile data_t * vol_a = a;
 7f5:	48 8b 1d 00 00 00 00 	mov    rbx,QWORD PTR [rip+0x0]        # 7fc <r_stride_4()+0xc>	7f8: R_X86_64_PC32	a-0x4
        volatile register data_t res = vol_a[i];
    }
    return get_time() - elapsed;
}

double r_stride_4(){
 7fc:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 805:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
 80a:	31 c0                	xor    eax,eax
    volatile data_t * vol_a = a;
    double elapsed = get_time();
 80c:	e8 00 00 00 00       	call   811 <r_stride_4()+0x21>	80d: R_X86_64_PC32	get_time()-0x4
 811:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
 816:	31 c9                	xor    ecx,ecx
 818:	31 d2                	xor    edx,edx
 81a:	bf 00 00 00 00       	mov    edi,0x0	81b: R_X86_64_32	.text+0x2d0
 81f:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
    #pragma omp parallel for
 825:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
 82a:	e8 00 00 00 00       	call   82f <r_stride_4()+0x3f>	82b: R_X86_64_PC32	GOMP_parallel-0x4
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 4) {
        volatile register data_t res = vol_a[i];
    }
    return get_time() - elapsed;
 82f:	e8 00 00 00 00       	call   834 <r_stride_4()+0x44>	830: R_X86_64_PC32	get_time()-0x4
}
 834:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
 839:	64 48 33 04 25 28 00 00 00 	xor    rax,QWORD PTR fs:0x28
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 4) {
        volatile register data_t res = vol_a[i];
    }
    return get_time() - elapsed;
 842:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 848:	75 06                	jne    850 <r_stride_4()+0x60>
 84a:	48 83 c4 20          	add    rsp,0x20
 84e:	5b                   	pop    rbx
 84f:	c3                   	ret    
 850:	e8 00 00 00 00       	call   855 <r_stride_4()+0x65>	851: R_X86_64_PC32	__stack_chk_fail-0x4
 855:	90                   	nop
 856:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

0000000000000860 <r_stride_8()>:

double r_stride_8(){
 860:	53                   	push   rbx
 861:	48 83 ec 20          	sub    rsp,0x20
    volatile data_t * vol_a = a;
 865:	48 8b 1d 00 00 00 00 	mov    rbx,QWORD PTR [rip+0x0]        # 86c <r_stride_8()+0xc>	868: R_X86_64_PC32	a-0x4
        volatile register data_t res = vol_a[i];
    }
    return get_time() - elapsed;
}

double r_stride_8(){
 86c:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 875:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
 87a:	31 c0                	xor    eax,eax
    volatile data_t * vol_a = a;
    double elapsed = get_time();
 87c:	e8 00 00 00 00       	call   881 <r_stride_8()+0x21>	87d: R_X86_64_PC32	get_time()-0x4
 881:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
 886:	31 c9                	xor    ecx,ecx
 888:	31 d2                	xor    edx,edx
 88a:	bf 00 00 00 00       	mov    edi,0x0	88b: R_X86_64_32	.text+0x340
 88f:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
    #pragma omp parallel for
 895:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
 89a:	e8 00 00 00 00       	call   89f <r_stride_8()+0x3f>	89b: R_X86_64_PC32	GOMP_parallel-0x4
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 8) {
        volatile register data_t res = vol_a[i];
    }
    return get_time() - elapsed;
 89f:	e8 00 00 00 00       	call   8a4 <r_stride_8()+0x44>	8a0: R_X86_64_PC32	get_time()-0x4
}
 8a4:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
 8a9:	64 48 33 04 25 28 00 00 00 	xor    rax,QWORD PTR fs:0x28
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 8) {
        volatile register data_t res = vol_a[i];
    }
    return get_time() - elapsed;
 8b2:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 8b8:	75 06                	jne    8c0 <r_stride_8()+0x60>
 8ba:	48 83 c4 20          	add    rsp,0x20
 8be:	5b                   	pop    rbx
 8bf:	c3                   	ret    
 8c0:	e8 00 00 00 00       	call   8c5 <r_stride_8()+0x65>	8c1: R_X86_64_PC32	__stack_chk_fail-0x4
 8c5:	90                   	nop
 8c6:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

00000000000008d0 <r_stride_16()>:

double r_stride_16(){
 8d0:	53                   	push   rbx
 8d1:	48 83 ec 20          	sub    rsp,0x20
    volatile data_t * vol_a = a;
 8d5:	48 8b 1d 00 00 00 00 	mov    rbx,QWORD PTR [rip+0x0]        # 8dc <r_stride_16()+0xc>	8d8: R_X86_64_PC32	a-0x4
        volatile register data_t res = vol_a[i];
    }
    return get_time() - elapsed;
}

double r_stride_16(){
 8dc:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 8e5:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
 8ea:	31 c0                	xor    eax,eax
    volatile data_t * vol_a = a;
    double elapsed = get_time();
 8ec:	e8 00 00 00 00       	call   8f1 <r_stride_16()+0x21>	8ed: R_X86_64_PC32	get_time()-0x4
 8f1:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
 8f6:	31 c9                	xor    ecx,ecx
 8f8:	31 d2                	xor    edx,edx
 8fa:	bf 00 00 00 00       	mov    edi,0x0	8fb: R_X86_64_32	.text+0x3b0
 8ff:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
    #pragma omp parallel for
 905:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
 90a:	e8 00 00 00 00       	call   90f <r_stride_16()+0x3f>	90b: R_X86_64_PC32	GOMP_parallel-0x4
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 16) {
        volatile register data_t res = vol_a[i];
    }
    return get_time() - elapsed;
 90f:	e8 00 00 00 00       	call   914 <r_stride_16()+0x44>	910: R_X86_64_PC32	get_time()-0x4
}
 914:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
 919:	64 48 33 04 25 28 00 00 00 	xor    rax,QWORD PTR fs:0x28
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 16) {
        volatile register data_t res = vol_a[i];
    }
    return get_time() - elapsed;
 922:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 928:	75 06                	jne    930 <r_stride_16()+0x60>
 92a:	48 83 c4 20          	add    rsp,0x20
 92e:	5b                   	pop    rbx
 92f:	c3                   	ret    
 930:	e8 00 00 00 00       	call   935 <r_stride_16()+0x65>	931: R_X86_64_PC32	__stack_chk_fail-0x4
 935:	90                   	nop
 936:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

0000000000000940 <r_stride_32()>:

double r_stride_32(){
 940:	53                   	push   rbx
 941:	48 83 ec 20          	sub    rsp,0x20
    volatile data_t * vol_a = a;
 945:	48 8b 1d 00 00 00 00 	mov    rbx,QWORD PTR [rip+0x0]        # 94c <r_stride_32()+0xc>	948: R_X86_64_PC32	a-0x4
        volatile register data_t res = vol_a[i];
    }
    return get_time() - elapsed;
}

double r_stride_32(){
 94c:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 955:	48 89 44 24 18       	mov    QWORD PTR [rsp+0x18],rax
 95a:	31 c0                	xor    eax,eax
    volatile data_t * vol_a = a;
    double elapsed = get_time();
 95c:	e8 00 00 00 00       	call   961 <r_stride_32()+0x21>	95d: R_X86_64_PC32	get_time()-0x4
 961:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
 966:	31 c9                	xor    ecx,ecx
 968:	31 d2                	xor    edx,edx
 96a:	bf 00 00 00 00       	mov    edi,0x0	96b: R_X86_64_32	.text+0x420
 96f:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
    #pragma omp parallel for
 975:	48 89 5c 24 10       	mov    QWORD PTR [rsp+0x10],rbx
 97a:	e8 00 00 00 00       	call   97f <r_stride_32()+0x3f>	97b: R_X86_64_PC32	GOMP_parallel-0x4
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 32) {
        volatile register data_t res = vol_a[i];
    }
    return get_time() - elapsed;
 97f:	e8 00 00 00 00       	call   984 <r_stride_32()+0x44>	980: R_X86_64_PC32	get_time()-0x4
}
 984:	48 8b 44 24 18       	mov    rax,QWORD PTR [rsp+0x18]
 989:	64 48 33 04 25 28 00 00 00 	xor    rax,QWORD PTR fs:0x28
    double elapsed = get_time();
    #pragma omp parallel for
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += 32) {
        volatile register data_t res = vol_a[i];
    }
    return get_time() - elapsed;
 992:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 998:	75 06                	jne    9a0 <r_stride_32()+0x60>
 99a:	48 83 c4 20          	add    rsp,0x20
 99e:	5b                   	pop    rbx
 99f:	c3                   	ret    
 9a0:	e8 00 00 00 00       	call   9a5 <r_stride_32()+0x65>	9a1: R_X86_64_PC32	__stack_chk_fail-0x4
 9a5:	90                   	nop
 9a6:	66 2e 0f 1f 84 00 00 00 00 00 	nop    WORD PTR cs:[rax+rax*1+0x0]

00000000000009b0 <r_tile(unsigned long, unsigned long)>:

double r_tile(uint64_t L, uint64_t K){
 9b0:	41 54                	push   r12
 9b2:	55                   	push   rbp
 9b3:	49 89 fc             	mov    r12,rdi
 9b6:	53                   	push   rbx
 9b7:	48 89 f5             	mov    rbp,rsi
 9ba:	48 83 ec 30          	sub    rsp,0x30
//double r_tile(){
    volatile data_t * vol_a = a;
 9be:	48 8b 1d 00 00 00 00 	mov    rbx,QWORD PTR [rip+0x0]        # 9c5 <r_tile(unsigned long, unsigned long)+0x15>	9c1: R_X86_64_PC32	a-0x4
        volatile register data_t res = vol_a[i];
    }
    return get_time() - elapsed;
}

double r_tile(uint64_t L, uint64_t K){
 9c5:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 9ce:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
 9d3:	31 c0                	xor    eax,eax
//double r_tile(){
    volatile data_t * vol_a = a;
    double elapsed = get_time();
 9d5:	e8 00 00 00 00       	call   9da <r_tile(unsigned long, unsigned long)+0x2a>	9d6: R_X86_64_PC32	get_time()-0x4
 9da:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
 9df:	31 c9                	xor    ecx,ecx
 9e1:	31 d2                	xor    edx,edx
 9e3:	bf 00 00 00 00       	mov    edi,0x0	9e4: R_X86_64_32	.text+0x490
 9e8:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
    #pragma omp parallel for
 9ee:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
 9f3:	48 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],rbp
 9f8:	48 89 5c 24 20       	mov    QWORD PTR [rsp+0x20],rbx
 9fd:	e8 00 00 00 00       	call   a02 <r_tile(unsigned long, unsigned long)+0x52>	9fe: R_X86_64_PC32	GOMP_parallel-0x4
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
            volatile data_t res = vol_a[i+j];
        }
    }
    return get_time() - elapsed;
 a02:	e8 00 00 00 00       	call   a07 <r_tile(unsigned long, unsigned long)+0x57>	a03: R_X86_64_PC32	get_time()-0x4
}
 a07:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
 a0c:	64 48 33 04 25 28 00 00 00 	xor    rax,QWORD PTR fs:0x28
    for(uint64_t i = 0; i < HS_ARRAY_ELEM; i += K) {
        for(uint64_t j = 0; j < L; j++) {
            volatile data_t res = vol_a[i+j];
        }
    }
    return get_time() - elapsed;
 a15:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
}
 a1b:	75 09                	jne    a26 <r_tile(unsigned long, unsigned long)+0x76>
 a1d:	48 83 c4 30          	add    rsp,0x30
 a21:	5b                   	pop    rbx
 a22:	5d                   	pop    rbp
 a23:	41 5c                	pop    r12
 a25:	c3                   	ret    
 a26:	e8 00 00 00 00       	call   a2b <r_tile(unsigned long, unsigned long)+0x7b>	a27: R_X86_64_PC32	__stack_chk_fail-0x4
 a2b:	0f 1f 44 00 00       	nop    DWORD PTR [rax+rax*1+0x0]

0000000000000a30 <r_dma(unsigned long**, unsigned long*, unsigned long)>:

double r_dma(data_t** addr, uint64_t* len, uint64_t count) {
 a30:	41 54                	push   r12
 a32:	55                   	push   rbp
 a33:	49 89 fc             	mov    r12,rdi
 a36:	53                   	push   rbx
 a37:	48 89 f5             	mov    rbp,rsi
 a3a:	48 89 d3             	mov    rbx,rdx
 a3d:	48 83 ec 30          	sub    rsp,0x30
 a41:	64 48 8b 04 25 28 00 00 00 	mov    rax,QWORD PTR fs:0x28
 a4a:	48 89 44 24 28       	mov    QWORD PTR [rsp+0x28],rax
 a4f:	31 c0                	xor    eax,eax
    volatile data_t * vol_a = a;
    double elapsed = get_time();
 a51:	e8 00 00 00 00       	call   a56 <r_dma(unsigned long**, unsigned long*, unsigned long)+0x26>	a52: R_X86_64_PC32	get_time()-0x4
 a56:	48 8d 74 24 10       	lea    rsi,[rsp+0x10]
 a5b:	31 c9                	xor    ecx,ecx
 a5d:	31 d2                	xor    edx,edx
 a5f:	bf 00 00 00 00       	mov    edi,0x0	a60: R_X86_64_32	.text+0x540
 a64:	c5 fb 11 44 24 08    	vmovsd QWORD PTR [rsp+0x8],xmm0
    #pragma omp parallel for
 a6a:	4c 89 64 24 10       	mov    QWORD PTR [rsp+0x10],r12
 a6f:	48 89 6c 24 18       	mov    QWORD PTR [rsp+0x18],rbp
 a74:	48 89 5c 24 20       	mov    QWORD PTR [rsp+0x20],rbx
 a79:	e8 00 00 00 00       	call   a7e <r_dma(unsigned long**, unsigned long*, unsigned long)+0x4e>	a7a: R_X86_64_PC32	GOMP_parallel-0x4
        volatile const data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
            volatile data_t res = *c_addr++;
        }
    }
    return get_time() - elapsed;
 a7e:	e8 00 00 00 00       	call   a83 <r_dma(unsigned long**, unsigned long*, unsigned long)+0x53>	a7f: R_X86_64_PC32	get_time()-0x4
 a83:	48 8b 44 24 28       	mov    rax,QWORD PTR [rsp+0x28]
 a88:	64 48 33 04 25 28 00 00 00 	xor    rax,QWORD PTR fs:0x28
        volatile const data_t* c_addr = addr[i];
        for(uint64_t j = 0; j < c_len; j++) {
            volatile data_t res = *c_addr++;
        }
    }
    return get_time() - elapsed;
 a91:	c5 fb 5c 44 24 08    	vsubsd xmm0,xmm0,QWORD PTR [rsp+0x8]
 a97:	75 09                	jne    aa2 <r_dma(unsigned long**, unsigned long*, unsigned long)+0x72>
 a99:	48 83 c4 30          	add    rsp,0x30
 a9d:	5b                   	pop    rbx
 a9e:	5d                   	pop    rbp
 a9f:	41 5c                	pop    r12
 aa1:	c3                   	ret    
 aa2:	e8 00 00 00 00       	call   aa7 <r_dma(unsigned long**, unsigned long*, unsigned long)+0x77>	aa3: R_X86_64_PC32	__stack_chk_fail-0x4
